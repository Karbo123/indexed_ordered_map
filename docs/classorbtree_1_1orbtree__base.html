<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>orbtree: orbtree::orbtree_base&lt; NodeAllocator, Compare, NVFunc, multi &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">orbtree
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>orbtree</b></li><li class="navelem"><a class="el" href="classorbtree_1_1orbtree__base.html">orbtree_base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classorbtree_1_1orbtree__base-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">orbtree::orbtree_base&lt; NodeAllocator, Compare, NVFunc, multi &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>base class for both map and set &ndash; should not be used directly  
 <a href="classorbtree_1_1orbtree__base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="orbtree__base_8h_source.html">orbtree_base.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for orbtree::orbtree_base&lt; NodeAllocator, Compare, NVFunc, multi &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classorbtree_1_1orbtree__base__inherit__graph.png" border="0" usemap="#orbtree_1_1orbtree__base_3_01NodeAllocator_00_01Compare_00_01NVFunc_00_01multi_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="orbtree_1_1orbtree__base_3_01NodeAllocator_00_01Compare_00_01NVFunc_00_01multi_01_4_inherit__map" id="orbtree_1_1orbtree__base_3_01NodeAllocator_00_01Compare_00_01NVFunc_00_01multi_01_4_inherit__map">
<area shape="rect" id="node3" href="classorbtree_1_1orbtree.html" title="Generalized order statistic tree main interface. It is recommended to use the templates orbset..." alt="" coords="387,5,595,47"/>
<area shape="rect" id="node4" href="classorbtree_1_1orbtree.html" title="orbtree\&lt; NodeAllocator,\l Compare, NVFunc, false \&gt;" alt="" coords="399,71,582,112"/>
<area shape="rect" id="node5" href="classorbtree_1_1orbtreemap.html" title="Base class with map&#45;specific function. It is recommended to use the specializations orbmap..." alt="" coords="643,63,824,119"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for orbtree::orbtree_base&lt; NodeAllocator, Compare, NVFunc, multi &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classorbtree_1_1orbtree__base__coll__graph.png" border="0" usemap="#orbtree_1_1orbtree__base_3_01NodeAllocator_00_01Compare_00_01NVFunc_00_01multi_01_4_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad94ad812f92bd1f2f156d6140a2833a0"><td class="memItemLeft" align="right" valign="top"><a id="ad94ad812f92bd1f2f156d6140a2833a0"></a>
typedef NodeAllocator::NVType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a></td></tr>
<tr class="memdesc:ad94ad812f92bd1f2f156d6140a2833a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type the function NVFunc returns. <br /></td></tr>
<tr class="separator:ad94ad812f92bd1f2f156d6140a2833a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abda5fbabf03eef9a04072d3bbef1201f"><td class="memItemLeft" align="right" valign="top"><a id="abda5fbabf03eef9a04072d3bbef1201f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#abda5fbabf03eef9a04072d3bbef1201f">clear</a> ()</td></tr>
<tr class="memdesc:abda5fbabf03eef9a04072d3bbef1201f"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase all nodes <br /></td></tr>
<tr class="separator:abda5fbabf03eef9a04072d3bbef1201f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95df4d552f3d7df3eac7cdb1f2d4ad14"><td class="memTemplParams" colspan="2"><a id="a95df4d552f3d7df3eac7cdb1f2d4ad14"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a95df4d552f3d7df3eac7cdb1f2d4ad14"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a95df4d552f3d7df3eac7cdb1f2d4ad14">get_sum_fv</a> (const K &amp;k, <a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a> *res) const</td></tr>
<tr class="memdesc:a95df4d552f3d7df3eac7cdb1f2d4ad14"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the generalized rank for a key, i.e. the sum of NVFunc for all nodes with node.key &lt; k <br /></td></tr>
<tr class="separator:a95df4d552f3d7df3eac7cdb1f2d4ad14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fc2a50100d3c50fc10857628ea0051"><td class="memItemLeft" align="right" valign="top"><a id="ae2fc2a50100d3c50fc10857628ea0051"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ae2fc2a50100d3c50fc10857628ea0051">get_sum_fv_node</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> x, <a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a> *res) const</td></tr>
<tr class="memdesc:ae2fc2a50100d3c50fc10857628ea0051"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the generalized rank for a given node, i.e. the sum of NVFunv for all nodes before it in order <br /></td></tr>
<tr class="separator:ae2fc2a50100d3c50fc10857628ea0051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfd4e40f0441cd5024f1006cfbb6b9d"><td class="memItemLeft" align="right" valign="top"><a id="a0bfd4e40f0441cd5024f1006cfbb6b9d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a0bfd4e40f0441cd5024f1006cfbb6b9d">get_norm_fv</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a> *res) const</td></tr>
<tr class="memdesc:a0bfd4e40f0441cd5024f1006cfbb6b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the normalization factor, i.e. the sum of all keys <br /></td></tr>
<tr class="separator:a0bfd4e40f0441cd5024f1006cfbb6b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05c1bb18a593ec67dbd8104f2c12b50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ae05c1bb18a593ec67dbd8104f2c12b50">check_tree</a> (double epsilon=-1.0) const</td></tr>
<tr class="memdesc:ae05c1bb18a593ec67dbd8104f2c12b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">check that the tree is valid  <a href="#ae05c1bb18a593ec67dbd8104f2c12b50">More...</a><br /></td></tr>
<tr class="separator:ae05c1bb18a593ec67dbd8104f2c12b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a882123f478b791f197264cf0be6859"><td class="memTemplParams" colspan="2"><a id="a7a882123f478b791f197264cf0be6859"></a>
template&lt;class... T&gt; </td></tr>
<tr class="memitem:a7a882123f478b791f197264cf0be6859"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace</b> (T &amp;&amp;... t) -&gt; std::pair&lt; <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>, bool &gt;</td></tr>
<tr class="separator:a7a882123f478b791f197264cf0be6859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119752977bd6abaf3b662df85b22255c"><td class="memTemplParams" colspan="2"><a id="a119752977bd6abaf3b662df85b22255c"></a>
template&lt;class... T&gt; </td></tr>
<tr class="memitem:a119752977bd6abaf3b662df85b22255c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_hint</b> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> hint, T &amp;&amp;... t) -&gt; <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a></td></tr>
<tr class="separator:a119752977bd6abaf3b662df85b22255c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a5912e87855b088de32ea2be5030bd848"><td class="memItemLeft" align="right" valign="top"><a id="a5912e87855b088de32ea2be5030bd848"></a>
typedef NodeAllocator::Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a></td></tr>
<tr class="memdesc:a5912e87855b088de32ea2be5030bd848"><td class="mdescLeft">&#160;</td><td class="mdescRight">node objects <br /></td></tr>
<tr class="separator:a5912e87855b088de32ea2be5030bd848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2517a6321b0effc53eb6a1fad87642"><td class="memItemLeft" align="right" valign="top"><a id="a8c2517a6321b0effc53eb6a1fad87642"></a>
typedef NodeAllocator::KeyValue&#160;</td><td class="memItemRight" valign="bottom"><b>KeyValue</b></td></tr>
<tr class="separator:a8c2517a6321b0effc53eb6a1fad87642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f7b4d38a621ca5749f5ff9ed55d12d"><td class="memItemLeft" align="right" valign="top"><a id="a67f7b4d38a621ca5749f5ff9ed55d12d"></a>
typedef NodeAllocator::KeyValue::KeyType&#160;</td><td class="memItemRight" valign="bottom"><b>KeyType</b></td></tr>
<tr class="separator:a67f7b4d38a621ca5749f5ff9ed55d12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ba1b334a2d33d146b3e62d6b89c0a1"><td class="memItemLeft" align="right" valign="top"><a id="a65ba1b334a2d33d146b3e62d6b89c0a1"></a>
typedef NodeAllocator::KeyValue::ValueType&#160;</td><td class="memItemRight" valign="bottom"><b>ValueType</b></td></tr>
<tr class="separator:a65ba1b334a2d33d146b3e62d6b89c0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652905b3ff5eb2166f427aa7f558d498"><td class="memItemLeft" align="right" valign="top"><a id="a652905b3ff5eb2166f427aa7f558d498"></a>
typedef NodeAllocator::NodeHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a></td></tr>
<tr class="memdesc:a652905b3ff5eb2166f427aa7f558d498"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle to refer nodes to (pointer or integer) <br /></td></tr>
<tr class="separator:a652905b3ff5eb2166f427aa7f558d498"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2f11984af283322c6b4499bca5ae92ab"><td class="memItemLeft" align="right" valign="top"><a id="a2f11984af283322c6b4499bca5ae92ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a2f11984af283322c6b4499bca5ae92ab">NVAdd</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a> *x, const <a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a> *y) const</td></tr>
<tr class="memdesc:a2f11984af283322c6b4499bca5ae92ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to add NVType values; checks for overflow and throws exception in the case of integral types <br /></td></tr>
<tr class="separator:a2f11984af283322c6b4499bca5ae92ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac02719774296a202210b3f2ebbf8c18"><td class="memItemLeft" align="right" valign="top"><a id="aac02719774296a202210b3f2ebbf8c18"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#aac02719774296a202210b3f2ebbf8c18">NVSubtract</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a> *x, const <a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a> *y) const</td></tr>
<tr class="memdesc:aac02719774296a202210b3f2ebbf8c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to subtract NVType values; checks for overflow and throws exception in the case of integral types <br /></td></tr>
<tr class="separator:aac02719774296a202210b3f2ebbf8c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f409bc49cd728e3a26a0a31eae73524"><td class="memItemLeft" align="right" valign="top"><a id="a8f409bc49cd728e3a26a0a31eae73524"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>create_sentinels</b> ()</td></tr>
<tr class="separator:a8f409bc49cd728e3a26a0a31eae73524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340e5dba4f706fb00237c3273db222f2"><td class="memItemLeft" align="right" valign="top"><a id="a340e5dba4f706fb00237c3273db222f2"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a340e5dba4f706fb00237c3273db222f2">get_node</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n)</td></tr>
<tr class="memdesc:a340e5dba4f706fb00237c3273db222f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function that returns node object for a node handle <br /></td></tr>
<tr class="separator:a340e5dba4f706fb00237c3273db222f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a04bf4f4cbd380f55bd67217f78143"><td class="memItemLeft" align="right" valign="top"><a id="aa8a04bf4f4cbd380f55bd67217f78143"></a>
const <a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#aa8a04bf4f4cbd380f55bd67217f78143">get_node</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:aa8a04bf4f4cbd380f55bd67217f78143"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function that returns node object for a node handle <br /></td></tr>
<tr class="separator:aa8a04bf4f4cbd380f55bd67217f78143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1ce6c48fab1be08446ecf367af59e1"><td class="memItemLeft" align="right" valign="top"><a id="a7d1ce6c48fab1be08446ecf367af59e1"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a7d1ce6c48fab1be08446ecf367af59e1">root</a> () const</td></tr>
<tr class="memdesc:a7d1ce6c48fab1be08446ecf367af59e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle of root sentinel <br /></td></tr>
<tr class="separator:a7d1ce6c48fab1be08446ecf367af59e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10de0a6bb5dbdcadf06f821a8cdd17c3"><td class="memItemLeft" align="right" valign="top"><a id="a10de0a6bb5dbdcadf06f821a8cdd17c3"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a10de0a6bb5dbdcadf06f821a8cdd17c3">nil</a> () const</td></tr>
<tr class="memdesc:a10de0a6bb5dbdcadf06f821a8cdd17c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle of nil sentinel <br /></td></tr>
<tr class="separator:a10de0a6bb5dbdcadf06f821a8cdd17c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38005be543419c33fc8087dcbc6ca0e4"><td class="memItemLeft" align="right" valign="top"><a id="a38005be543419c33fc8087dcbc6ca0e4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>orbtree_base</b> (const NVFunc &amp;f_, const Compare &amp;c_)</td></tr>
<tr class="separator:a38005be543419c33fc8087dcbc6ca0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958aa7faf3a6f99967d01d51c4dde35b"><td class="memItemLeft" align="right" valign="top"><a id="a958aa7faf3a6f99967d01d51c4dde35b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>orbtree_base</b> (NVFunc &amp;&amp;f_, const Compare &amp;c_)</td></tr>
<tr class="separator:a958aa7faf3a6f99967d01d51c4dde35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dc66c1458508a0e07ca807d892bd8d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#af0dc66c1458508a0e07ca807d892bd8d">insert</a> (ValueType &amp;&amp;kv)</td></tr>
<tr class="memdesc:af0dc66c1458508a0e07ca807d892bd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new element.  <a href="#af0dc66c1458508a0e07ca807d892bd8d">More...</a><br /></td></tr>
<tr class="separator:af0dc66c1458508a0e07ca807d892bd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df163156f3b051f64d1d7f6a8c5fa49"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a6df163156f3b051f64d1d7f6a8c5fa49">insert</a> (const ValueType &amp;kv)</td></tr>
<tr class="memdesc:a6df163156f3b051f64d1d7f6a8c5fa49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new element.  <a href="#a6df163156f3b051f64d1d7f6a8c5fa49">More...</a><br /></td></tr>
<tr class="separator:a6df163156f3b051f64d1d7f6a8c5fa49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039050dc8bfea58a1f2be1562d2bcfe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a039050dc8bfea58a1f2be1562d2bcfe5">insert</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> hint, ValueType &amp;&amp;kv)</td></tr>
<tr class="memdesc:a039050dc8bfea58a1f2be1562d2bcfe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new element with hint.  <a href="#a039050dc8bfea58a1f2be1562d2bcfe5">More...</a><br /></td></tr>
<tr class="separator:a039050dc8bfea58a1f2be1562d2bcfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d07029a57c517922f7290fddcc866df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a4d07029a57c517922f7290fddcc866df">insert</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> hint, const ValueType &amp;kv)</td></tr>
<tr class="memdesc:a4d07029a57c517922f7290fddcc866df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new element with hint.  <a href="#a4d07029a57c517922f7290fddcc866df">More...</a><br /></td></tr>
<tr class="separator:a4d07029a57c517922f7290fddcc866df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3237f082391ba490c1c3604e932d5417"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:a3237f082391ba490c1c3604e932d5417"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a3237f082391ba490c1c3604e932d5417">emplace</a> (T &amp;&amp;... t)</td></tr>
<tr class="memdesc:a3237f082391ba490c1c3604e932d5417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct new element in place.  <a href="#a3237f082391ba490c1c3604e932d5417">More...</a><br /></td></tr>
<tr class="separator:a3237f082391ba490c1c3604e932d5417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200289ad5fdc385987b6325495fe988f"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:a200289ad5fdc385987b6325495fe988f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a200289ad5fdc385987b6325495fe988f">emplace_hint</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> hint, T &amp;&amp;... t)</td></tr>
<tr class="memdesc:a200289ad5fdc385987b6325495fe988f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct new element in place with hint.  <a href="#a200289ad5fdc385987b6325495fe988f">More...</a><br /></td></tr>
<tr class="separator:a200289ad5fdc385987b6325495fe988f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd31623c93494bd95ff14867329fff6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a3bd31623c93494bd95ff14867329fff6">insert_search</a> (const KeyType &amp;k, <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> &amp;n, bool &amp;insert_left) const</td></tr>
<tr class="memdesc:a3bd31623c93494bd95ff14867329fff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper for insert &ndash; find the location where to insert  <a href="#a3bd31623c93494bd95ff14867329fff6">More...</a><br /></td></tr>
<tr class="separator:a3bd31623c93494bd95ff14867329fff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6358fbacede2dab1e0783b9b78e400e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a6358fbacede2dab1e0783b9b78e400e8">insert_search_hint</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> hint, const KeyType &amp;k, <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> &amp;n, bool &amp;insert_left) const</td></tr>
<tr class="memdesc:a6358fbacede2dab1e0783b9b78e400e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper for insert &ndash; find the location where to insert  <a href="#a6358fbacede2dab1e0783b9b78e400e8">More...</a><br /></td></tr>
<tr class="separator:a6358fbacede2dab1e0783b9b78e400e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52ddab1f32195085b53311712f21f76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ac52ddab1f32195085b53311712f21f76">insert_helper</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n, <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n1, bool insert_left)</td></tr>
<tr class="memdesc:ac52ddab1f32195085b53311712f21f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to do the real work for insert  <a href="#ac52ddab1f32195085b53311712f21f76">More...</a><br /></td></tr>
<tr class="separator:ac52ddab1f32195085b53311712f21f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66b464b7b745a1f402e17842a037083"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:ae66b464b7b745a1f402e17842a037083"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ae66b464b7b745a1f402e17842a037083">find</a> (const K &amp;key) const -&gt; <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a></td></tr>
<tr class="memdesc:ae66b464b7b745a1f402e17842a037083"><td class="mdescLeft">&#160;</td><td class="mdescRight">find any node with the given key  <a href="#ae66b464b7b745a1f402e17842a037083">More...</a><br /></td></tr>
<tr class="separator:ae66b464b7b745a1f402e17842a037083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94afd66e7745a0773237ded2135a9a0"><td class="memTemplParams" colspan="2"><a id="ad94afd66e7745a0773237ded2135a9a0"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:ad94afd66e7745a0773237ded2135a9a0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ad94afd66e7745a0773237ded2135a9a0">lower_bound</a> (const K &amp;key) const -&gt; <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a></td></tr>
<tr class="memdesc:ad94afd66e7745a0773237ded2135a9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first node not less than the given key &ndash; returns nil if none found <br /></td></tr>
<tr class="separator:ad94afd66e7745a0773237ded2135a9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960028ee70919aeac975881a0111875a"><td class="memTemplParams" colspan="2"><a id="a960028ee70919aeac975881a0111875a"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a960028ee70919aeac975881a0111875a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a960028ee70919aeac975881a0111875a">upper_bound</a> (const K &amp;key) const -&gt; <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a></td></tr>
<tr class="memdesc:a960028ee70919aeac975881a0111875a"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first node larger than the given key &ndash; returns nil if none found <br /></td></tr>
<tr class="separator:a960028ee70919aeac975881a0111875a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1581d4499f2bc74428671cb94530e7cb"><td class="memItemLeft" align="right" valign="top"><a id="a1581d4499f2bc74428671cb94530e7cb"></a>
const KeyType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a1581d4499f2bc74428671cb94530e7cb">get_node_key</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:a1581d4499f2bc74428671cb94530e7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function to get the key of a node <br /></td></tr>
<tr class="separator:a1581d4499f2bc74428671cb94530e7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05eae072c643a66f8edf4d0d8479a4a4"><td class="memItemLeft" align="right" valign="top"><a id="a05eae072c643a66f8edf4d0d8479a4a4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a05eae072c643a66f8edf4d0d8479a4a4">compare_key_equals</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n, const KeyType &amp;k) const</td></tr>
<tr class="memdesc:a05eae072c643a66f8edf4d0d8479a4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper for erase to compare elements <br /></td></tr>
<tr class="separator:a05eae072c643a66f8edf4d0d8479a4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb66c8e1850f5683fc6dc5dbd29dec1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#abb66c8e1850f5683fc6dc5dbd29dec1b">get_node_grvalue</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n, <a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a> *res) const</td></tr>
<tr class="memdesc:abb66c8e1850f5683fc6dc5dbd29dec1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the value of NVFunc for the given node  <a href="#abb66c8e1850f5683fc6dc5dbd29dec1b">More...</a><br /></td></tr>
<tr class="separator:abb66c8e1850f5683fc6dc5dbd29dec1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c92f44eef353e6feea10b24647a6850"><td class="memItemLeft" align="right" valign="top"><a id="a0c92f44eef353e6feea10b24647a6850"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a0c92f44eef353e6feea10b24647a6850">first</a> () const</td></tr>
<tr class="memdesc:a0c92f44eef353e6feea10b24647a6850"><td class="mdescLeft">&#160;</td><td class="mdescRight">get first node (or nil) <br /></td></tr>
<tr class="separator:a0c92f44eef353e6feea10b24647a6850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5478426317ce688d2c1a3ecf33efdc7a"><td class="memItemLeft" align="right" valign="top"><a id="a5478426317ce688d2c1a3ecf33efdc7a"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a5478426317ce688d2c1a3ecf33efdc7a">last</a> () const</td></tr>
<tr class="memdesc:a5478426317ce688d2c1a3ecf33efdc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get last node (or nil) <br /></td></tr>
<tr class="separator:a5478426317ce688d2c1a3ecf33efdc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e914d88fe2d60947318a036412cb69"><td class="memItemLeft" align="right" valign="top"><a id="ae2e914d88fe2d60947318a036412cb69"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ae2e914d88fe2d60947318a036412cb69">next</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:ae2e914d88fe2d60947318a036412cb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">get node after n (or nil) &ndash; note: next(nil) == nil <br /></td></tr>
<tr class="separator:ae2e914d88fe2d60947318a036412cb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90917516903a7116aae29025f91f59c0"><td class="memItemLeft" align="right" valign="top"><a id="a90917516903a7116aae29025f91f59c0"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a90917516903a7116aae29025f91f59c0">previous</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:a90917516903a7116aae29025f91f59c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">get node before n (or nil) &ndash; note: previous(nil) == <a class="el" href="classorbtree_1_1orbtree__base.html#a5478426317ce688d2c1a3ecf33efdc7a" title="get last node (or nil) ">last()</a> to make it easier to implement end() iterator <br /></td></tr>
<tr class="separator:a90917516903a7116aae29025f91f59c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7c194e2e1227886e2c8273f6531f59"><td class="memItemLeft" align="right" valign="top"><a id="a0b7c194e2e1227886e2c8273f6531f59"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a0b7c194e2e1227886e2c8273f6531f59">erase</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n)</td></tr>
<tr class="memdesc:a0b7c194e2e1227886e2c8273f6531f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the given node &ndash; return the next node (i.e. next(n) before deleting n) <br /></td></tr>
<tr class="separator:a0b7c194e2e1227886e2c8273f6531f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c60ee1b54d9615d995dab6256056984"><td class="memItemLeft" align="right" valign="top"><a id="a3c60ee1b54d9615d995dab6256056984"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a3c60ee1b54d9615d995dab6256056984">get_left</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n)</td></tr>
<tr class="memdesc:a3c60ee1b54d9615d995dab6256056984"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience helper to get node object that is the left child of the given node handle <br /></td></tr>
<tr class="separator:a3c60ee1b54d9615d995dab6256056984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05677939b594328aa1c49c2d6af9529"><td class="memItemLeft" align="right" valign="top"><a id="ab05677939b594328aa1c49c2d6af9529"></a>
const <a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ab05677939b594328aa1c49c2d6af9529">get_left</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:ab05677939b594328aa1c49c2d6af9529"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience helper to get node object that is the left child of the given node handle <br /></td></tr>
<tr class="separator:ab05677939b594328aa1c49c2d6af9529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a05d777bc25159b8cbc2eb8b6f9b07e"><td class="memItemLeft" align="right" valign="top"><a id="a3a05d777bc25159b8cbc2eb8b6f9b07e"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a3a05d777bc25159b8cbc2eb8b6f9b07e">get_right</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n)</td></tr>
<tr class="memdesc:a3a05d777bc25159b8cbc2eb8b6f9b07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience helper to get node object that is the right child of the given node handle <br /></td></tr>
<tr class="separator:a3a05d777bc25159b8cbc2eb8b6f9b07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edf15f1c988a532563ee5a327ac1384"><td class="memItemLeft" align="right" valign="top"><a id="a7edf15f1c988a532563ee5a327ac1384"></a>
const <a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a7edf15f1c988a532563ee5a327ac1384">get_right</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:a7edf15f1c988a532563ee5a327ac1384"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience helper to get node object that is the right child of the given node handle <br /></td></tr>
<tr class="separator:a7edf15f1c988a532563ee5a327ac1384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c8f9ff96f4e4f139ddb65c2dae6ec8"><td class="memItemLeft" align="right" valign="top"><a id="ac7c8f9ff96f4e4f139ddb65c2dae6ec8"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ac7c8f9ff96f4e4f139ddb65c2dae6ec8">get_parent</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n)</td></tr>
<tr class="memdesc:ac7c8f9ff96f4e4f139ddb65c2dae6ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience helper to get node object that is the parent of the given node handle <br /></td></tr>
<tr class="separator:ac7c8f9ff96f4e4f139ddb65c2dae6ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9640bfd4f7b326c79f1dd2d99faf4144"><td class="memItemLeft" align="right" valign="top"><a id="a9640bfd4f7b326c79f1dd2d99faf4144"></a>
const <a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a9640bfd4f7b326c79f1dd2d99faf4144">get_parent</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:a9640bfd4f7b326c79f1dd2d99faf4144"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience helper to get node object that is the parent of the given node handle <br /></td></tr>
<tr class="separator:a9640bfd4f7b326c79f1dd2d99faf4144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b55bbeead05fb1de7d7da23933d333"><td class="memItemLeft" align="right" valign="top"><a id="ad7b55bbeead05fb1de7d7da23933d333"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ad7b55bbeead05fb1de7d7da23933d333">get_sibling_handle</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:ad7b55bbeead05fb1de7d7da23933d333"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience helper to get the handle of a node's sibling (i.e. parent's other child) <br /></td></tr>
<tr class="separator:ad7b55bbeead05fb1de7d7da23933d333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5754e3fabc8a6bb299b53d33f71cba20"><td class="memItemLeft" align="right" valign="top"><a id="a5754e3fabc8a6bb299b53d33f71cba20"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a5754e3fabc8a6bb299b53d33f71cba20">get_sibling</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n)</td></tr>
<tr class="memdesc:a5754e3fabc8a6bb299b53d33f71cba20"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience helper to get the node object of a node's sibling (i.e. parent's other child) <br /></td></tr>
<tr class="separator:a5754e3fabc8a6bb299b53d33f71cba20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12fc3eb265da99f98b5b76702322b46"><td class="memItemLeft" align="right" valign="top"><a id="aa12fc3eb265da99f98b5b76702322b46"></a>
const <a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#aa12fc3eb265da99f98b5b76702322b46">get_sibling</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:aa12fc3eb265da99f98b5b76702322b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience helper to get the node object of a node's sibling (i.e. parent's other child) <br /></td></tr>
<tr class="separator:aa12fc3eb265da99f98b5b76702322b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fa240f80095af695eed678e84a9641"><td class="memItemLeft" align="right" valign="top"><a id="a52fa240f80095af695eed678e84a9641"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a52fa240f80095af695eed678e84a9641">is_left_side</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:a52fa240f80095af695eed678e84a9641"><td class="mdescLeft">&#160;</td><td class="mdescRight">check which side child is n (i.e. returns true if n is the left child of its parent) &ndash; requires that n != root <br /></td></tr>
<tr class="separator:a52fa240f80095af695eed678e84a9641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c213e1b016ba48d64a983dcad5ad315"><td class="memItemLeft" align="right" valign="top"><a id="a1c213e1b016ba48d64a983dcad5ad315"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a1c213e1b016ba48d64a983dcad5ad315">update_sum</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n)</td></tr>
<tr class="memdesc:a1c213e1b016ba48d64a983dcad5ad315"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the sum only inside n <br /></td></tr>
<tr class="separator:a1c213e1b016ba48d64a983dcad5ad315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9214c4eb5277b64e7c7fd4cbbfc0844"><td class="memItemLeft" align="right" valign="top"><a id="af9214c4eb5277b64e7c7fd4cbbfc0844"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#af9214c4eb5277b64e7c7fd4cbbfc0844">update_sum_r</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n)</td></tr>
<tr class="memdesc:af9214c4eb5277b64e7c7fd4cbbfc0844"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the sum recursively up the tree <br /></td></tr>
<tr class="separator:af9214c4eb5277b64e7c7fd4cbbfc0844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efef5dfbb0163f75b27c7a43275950e"><td class="memTemplParams" colspan="2"><a id="a9efef5dfbb0163f75b27c7a43275950e"></a>
template&lt;class KeyValue_  = KeyValue&gt; </td></tr>
<tr class="memitem:a9efef5dfbb0163f75b27c7a43275950e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a9efef5dfbb0163f75b27c7a43275950e">update_value</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n, typename KeyValue_::MappedType const &amp;v)</td></tr>
<tr class="memdesc:a9efef5dfbb0163f75b27c7a43275950e"><td class="mdescLeft">&#160;</td><td class="mdescRight">update value in a node &ndash; only if this is a map; update sum recursively based on it as well <br /></td></tr>
<tr class="separator:a9efef5dfbb0163f75b27c7a43275950e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e20acaf610c7bacc3b6dc44512826a"><td class="memTemplParams" colspan="2"><a id="a37e20acaf610c7bacc3b6dc44512826a"></a>
template&lt;class KeyValue_  = KeyValue&gt; </td></tr>
<tr class="memitem:a37e20acaf610c7bacc3b6dc44512826a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a37e20acaf610c7bacc3b6dc44512826a">update_value</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n, typename KeyValue_::MappedType &amp;&amp;v)</td></tr>
<tr class="memdesc:a37e20acaf610c7bacc3b6dc44512826a"><td class="mdescLeft">&#160;</td><td class="mdescRight">update value in a node &ndash; only if this is a map; update sum recursively based on it as well <br /></td></tr>
<tr class="separator:a37e20acaf610c7bacc3b6dc44512826a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68eeccfe36447a54c3344fc79187b533"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a68eeccfe36447a54c3344fc79187b533">rotate_left</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> x)</td></tr>
<tr class="memdesc:a68eeccfe36447a54c3344fc79187b533"><td class="mdescLeft">&#160;</td><td class="mdescRight">left rotate  <a href="#a68eeccfe36447a54c3344fc79187b533">More...</a><br /></td></tr>
<tr class="separator:a68eeccfe36447a54c3344fc79187b533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537ce2b7bf2baeeef5dfb534a47a9f96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a537ce2b7bf2baeeef5dfb534a47a9f96">rotate_right</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> x)</td></tr>
<tr class="memdesc:a537ce2b7bf2baeeef5dfb534a47a9f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">right rotate  <a href="#a537ce2b7bf2baeeef5dfb534a47a9f96">More...</a><br /></td></tr>
<tr class="separator:a537ce2b7bf2baeeef5dfb534a47a9f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a7f731d8ee936c2d140bc7f0c3b734"><td class="memItemLeft" align="right" valign="top"><a id="a82a7f731d8ee936c2d140bc7f0c3b734"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a82a7f731d8ee936c2d140bc7f0c3b734">rotate_parent</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> x)</td></tr>
<tr class="memdesc:a82a7f731d8ee936c2d140bc7f0c3b734"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotate by parent of x (x takes parent's place), this calls either <a class="el" href="classorbtree_1_1orbtree__base.html#a68eeccfe36447a54c3344fc79187b533" title="left rotate ">rotate_left()</a> or <a class="el" href="classorbtree_1_1orbtree__base.html#a537ce2b7bf2baeeef5dfb534a47a9f96" title="right rotate ">rotate_right()</a> with the parent of x <br /></td></tr>
<tr class="separator:a82a7f731d8ee936c2d140bc7f0c3b734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95a96c37ba6e241eada4e623748200f"><td class="memItemLeft" align="right" valign="top"><a id="af95a96c37ba6e241eada4e623748200f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#af95a96c37ba6e241eada4e623748200f">check_tree_r</a> (double epsilon, <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> x, size_t black_count, size_t &amp;previous_black_count) const</td></tr>
<tr class="memdesc:af95a96c37ba6e241eada4e623748200f"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursive helper for check_tree(double) <br /></td></tr>
<tr class="separator:af95a96c37ba6e241eada4e623748200f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a65ffeb74cf7633cd43f16274c9522757"><td class="memItemLeft" align="right" valign="top"><a id="a65ffeb74cf7633cd43f16274c9522757"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a65ffeb74cf7633cd43f16274c9522757">size1</a></td></tr>
<tr class="memdesc:a65ffeb74cf7633cd43f16274c9522757"><td class="mdescLeft">&#160;</td><td class="mdescRight">keep track of the number of inserted elements <br /></td></tr>
<tr class="separator:a65ffeb74cf7633cd43f16274c9522757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9ac29180f46526d3139913425540e1"><td class="memItemLeft" align="right" valign="top"><a id="a4b9ac29180f46526d3139913425540e1"></a>
NVFunc&#160;</td><td class="memItemRight" valign="bottom"><b>f</b></td></tr>
<tr class="separator:a4b9ac29180f46526d3139913425540e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbed14df189c55d6ea4551cb1ea417ef"><td class="memItemLeft" align="right" valign="top"><a id="adbed14df189c55d6ea4551cb1ea417ef"></a>
Compare&#160;</td><td class="memItemRight" valign="bottom"><b>c</b></td></tr>
<tr class="separator:adbed14df189c55d6ea4551cb1ea417ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class NodeAllocator, class Compare, class NVFunc, bool multi&gt;<br />
class orbtree::orbtree_base&lt; NodeAllocator, Compare, NVFunc, multi &gt;</h3>

<p>base class for both map and set &ndash; should not be used directly </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NodeAllocator</td><td>Class taking care of allocating and freeing nodes, should be <a class="el" href="classorbtree_1_1NodeAllocatorPtr.html" title="Basic allocator that allocates each node individually, using C++ new / delete and pointers...">NodeAllocatorPtr</a> or <a class="el" href="classorbtree_1_1NodeAllocatorCompact.html" title="Alternate node allocator with the aim to use less memory. ">NodeAllocatorCompact</a> from <a class="el" href="orbtree__node_8h_source.html">orbtree_node.h</a> </td></tr>
    <tr><td class="paramname">Compare</td><td>Comparison functor </td></tr>
    <tr><td class="paramname">NVFunc</td><td>Function that calculates each node's "value" &ndash; it is assumed to be a vector-valued function, so these values are stored and manipulated in arrays. It should have a function get_nr() that return the number of values to use. See <a class="el" href="structorbtree_1_1NVFunc__Adapter__Simple.html" title="Adapter for functions that return only one result. ">NVFunc_Adapter_Simple</a> and <a class="el" href="structorbtree_1_1NVFunc__Adapter__Vec.html" title="adapter for functions that take one parameter from a vector of parameters ">NVFunc_Adapter_Vec</a> for examples. </td></tr>
    <tr><td class="paramname">multi</td><td>Whether multiple nodes with the same key are allowed. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae05c1bb18a593ec67dbd8104f2c12b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05c1bb18a593ec67dbd8104f2c12b50">&#9670;&nbsp;</a></span>check_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator , class Compare , class NVFunc , bool multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::check_tree </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>-1.0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check that the tree is valid </p>
<p>Checks that binary tree and red-black tree properties are OK, throws exception on error. Also checks that rank function values (partial sums) are consistent as well if epsilon &gt;= 0 (epsilon is the tolerance for rounding errors if NVType is not integral) </p>

</div>
</div>
<a id="a3237f082391ba490c1c3604e932d5417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3237f082391ba490c1c3604e932d5417">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator, class Compare, class NVFunc, bool multi&gt; </div>
<div class="memtemplate">
template&lt;class... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>,bool&gt; <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct new element in place. </p>
<p>Return type is always std::pair&lt;iterator,bool&gt;, where the first element is a handle to the newly inserted node and the second element indicates if insert was successful.</p>
<p>For multi map/set, insert always succeeds, to the second element is always true. In this case, a new element is always inserted after any existing elements with the same key.</p>
<p>For a non-multi map/set, insert fails if an element with the same key already exists. In this case, a handle to the element with the same key is returned along with false in the second element. </p>

</div>
</div>
<a id="a200289ad5fdc385987b6325495fe988f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200289ad5fdc385987b6325495fe988f">&#9670;&nbsp;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator, class Compare, class NVFunc, bool multi&gt; </div>
<div class="memtemplate">
template&lt;class... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct new element in place with hint. </p>
<p>Return type is always std::pair&lt;iterator,bool&gt;, where the first element is a handle to the newly inserted node and the second element indicates if insert was successful.</p>
<p>For multi map/set, insert always succeeds, to the second element is always true. In this case, a new element is always inserted after any existing elements with the same key.</p>
<p>For a non-multi map/set, insert fails if an element with the same key already exists. In this case, a handle to the element with the same key is returned along with false in the second element.</p>
<p>Caller suggests a position which is before the element pointed to by the supplied iterator.</p>
<p>For non-multi tree (map/set; i.e. duplicates are not allowed):</p><ul>
<li>if the hint points to the correct position (i.e. the new element should go before the element referenced by the hint iterator), then a search is not performed, so the insertion cost is amortized constant</li>
<li>in all other cases, the hint is ignored</li>
</ul>
<p>For multi tree (duplicate keys are allowed):</p><ul>
<li>if the key is equal to the key of element referenced by the hint iterator, then the new element is inserted before it</li>
<li>otherwise, the new element is inserted as close as possible </li>
</ul>

</div>
</div>
<a id="ae66b464b7b745a1f402e17842a037083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66b464b7b745a1f402e17842a037083">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator , class Compare , class NVFunc , bool multi&gt; </div>
<div class="memtemplate">
template&lt;class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find any node with the given key </p>
<p>K should be comparable to KeyType</p>
<p>returns nil if not found (to make it easier with iterators) </p>

</div>
</div>
<a id="abb66c8e1850f5683fc6dc5dbd29dec1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb66c8e1850f5683fc6dc5dbd29dec1b">&#9670;&nbsp;</a></span>get_node_grvalue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator, class Compare, class NVFunc, bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::get_node_grvalue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a> *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the value of NVFunc for the given node </p>
<p>should not be called with nil, root or Invalid</p>
<p>note that rank function can depend on a node's value as well; care need to be taken to update rank if a node's value changes! </p>

</div>
</div>
<a id="af0dc66c1458508a0e07ca807d892bd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0dc66c1458508a0e07ca807d892bd8d">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator , class Compare , class NVFunc , bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>kv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert new element. </p>
<p>Return type is always std::pair&lt;iterator,bool&gt;, where the first element is a handle to the newly inserted node and the second element indicates if insert was successful.</p>
<p>For multi map/set, insert always succeeds, to the second element is always true. In this case, a new element is always inserted after any existing elements with the same key.</p>
<p>For a non-multi map/set, insert fails if an element with the same key already exists. In this case, a handle to the element with the same key is returned along with false in the second element. </p>

</div>
</div>
<a id="a6df163156f3b051f64d1d7f6a8c5fa49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df163156f3b051f64d1d7f6a8c5fa49">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator , class Compare , class NVFunc , bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>kv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert new element. </p>
<p>Return type is always std::pair&lt;iterator,bool&gt;, where the first element is a handle to the newly inserted node and the second element indicates if insert was successful.</p>
<p>For multi map/set, insert always succeeds, to the second element is always true. In this case, a new element is always inserted after any existing elements with the same key.</p>
<p>For a non-multi map/set, insert fails if an element with the same key already exists. In this case, a handle to the element with the same key is returned along with false in the second element. </p>

</div>
</div>
<a id="a039050dc8bfea58a1f2be1562d2bcfe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039050dc8bfea58a1f2be1562d2bcfe5">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator , class Compare , class NVFunc , bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>kv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert new element with hint. </p>
<p>Return type is always std::pair&lt;iterator,bool&gt;, where the first element is a handle to the newly inserted node and the second element indicates if insert was successful.</p>
<p>For multi map/set, insert always succeeds, to the second element is always true. In this case, a new element is always inserted after any existing elements with the same key.</p>
<p>For a non-multi map/set, insert fails if an element with the same key already exists. In this case, a handle to the element with the same key is returned along with false in the second element.</p>
<p>Caller suggests a position which is before the element pointed to by the supplied iterator.</p>
<p>For non-multi tree (map/set; i.e. duplicates are not allowed):</p><ul>
<li>if the hint points to the correct position (i.e. the new element should go before the element referenced by the hint iterator), then a search is not performed, so the insertion cost is amortized constant</li>
<li>in all other cases, the hint is ignored</li>
</ul>
<p>For multi tree (duplicate keys are allowed):</p><ul>
<li>if the key is equal to the key of element referenced by the hint iterator, then the new element is inserted before it</li>
<li>otherwise, the new element is inserted as close as possible </li>
</ul>

</div>
</div>
<a id="a4d07029a57c517922f7290fddcc866df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d07029a57c517922f7290fddcc866df">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator , class Compare , class NVFunc , bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>kv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert new element with hint. </p>
<p>Return type is always std::pair&lt;iterator,bool&gt;, where the first element is a handle to the newly inserted node and the second element indicates if insert was successful.</p>
<p>For multi map/set, insert always succeeds, to the second element is always true. In this case, a new element is always inserted after any existing elements with the same key.</p>
<p>For a non-multi map/set, insert fails if an element with the same key already exists. In this case, a handle to the element with the same key is returned along with false in the second element.</p>
<p>Caller suggests a position which is before the element pointed to by the supplied iterator.</p>
<p>For non-multi tree (map/set; i.e. duplicates are not allowed):</p><ul>
<li>if the hint points to the correct position (i.e. the new element should go before the element referenced by the hint iterator), then a search is not performed, so the insertion cost is amortized constant</li>
<li>in all other cases, the hint is ignored</li>
</ul>
<p>For multi tree (duplicate keys are allowed):</p><ul>
<li>if the key is equal to the key of element referenced by the hint iterator, then the new element is inserted before it</li>
<li>otherwise, the new element is inserted as close as possible </li>
</ul>

</div>
</div>
<a id="ac52ddab1f32195085b53311712f21f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52ddab1f32195085b53311712f21f76">&#9670;&nbsp;</a></span>insert_helper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator , class Compare , class NVFunc , bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::insert_helper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>insert_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function to do the real work for insert </p>
<p>insert n1 as the left / right child of n</p>
<p>n1 must already contain the proper key / value, but can be uninitialized otherwise</p>
<p>note: this function does not check for the correct relationship between the keys of n and n1, that is the caller's responsibility </p>

</div>
</div>
<a id="a3bd31623c93494bd95ff14867329fff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd31623c93494bd95ff14867329fff6">&#9670;&nbsp;</a></span>insert_search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator , class Compare , class NVFunc , bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::insert_search </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>insert_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper for insert &ndash; find the location where to insert </p>
<p>note: in a multi map/set, the inserted element will come after any already existing elements with the same key</p>
<p>Return true if insert is possible, false if element already exists and this is a non-multi map/set. </p>

</div>
</div>
<a id="a6358fbacede2dab1e0783b9b78e400e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6358fbacede2dab1e0783b9b78e400e8">&#9670;&nbsp;</a></span>insert_search_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator , class Compare , class NVFunc , bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::insert_search_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>insert_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper for insert &ndash; find the location where to insert </p>
<p>note: in a multi map/set, the inserted element will come after any already existing elements with the same key</p>
<p>Return true if insert is possible, false if element already exists and this is a non-multi map/set.</p>
<p>Try to insert as close to hint as possible. Note: if hint is bad, it is ignored. </p>

</div>
</div>
<a id="a68eeccfe36447a54c3344fc79187b533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68eeccfe36447a54c3344fc79187b533">&#9670;&nbsp;</a></span>rotate_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator , class Compare , class NVFunc , bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::rotate_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>left rotate </p>
<p>right child of x takes its place, x becomes its left child left child of x's original right child becomes x's right child </p>

</div>
</div>
<a id="a537ce2b7bf2baeeef5dfb534a47a9f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537ce2b7bf2baeeef5dfb534a47a9f96">&#9670;&nbsp;</a></span>rotate_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator , class Compare , class NVFunc , bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::rotate_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>right rotate </p>
<p>left child of x takes its place, y becomes its right child right child of x's original left child becomes x's left child </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="orbtree__base_8h_source.html">orbtree_base.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
