<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>orbtree: realloc_vector::vector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">orbtree
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>realloc_vector</b></li><li class="navelem"><a class="el" href="classrealloc__vector_1_1vector.html">vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classrealloc__vector_1_1vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">realloc_vector::vector&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>C++ vector-like container for trivially moveable types, using realloc() for growing memory, with limits on maximum absolute growth.  
 <a href="classrealloc__vector_1_1vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vector__realloc_8h_source.html">vector_realloc.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for realloc_vector::vector&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classrealloc__vector_1_1vector__coll__graph.png" border="0" usemap="#realloc__vector_1_1vector_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a606e08620788ee4e5a53bbf4a8d0e47b"><td class="memItemLeft" align="right" valign="top"><a id="a606e08620788ee4e5a53bbf4a8d0e47b"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a606e08620788ee4e5a53bbf4a8d0e47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0d7f500b88bf0754e3be42a702d726"><td class="memItemLeft" align="right" valign="top"><a id="aeb0d7f500b88bf0754e3be42a702d726"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:aeb0d7f500b88bf0754e3be42a702d726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409745125b0b9dacce81c28aa4fa681f"><td class="memItemLeft" align="right" valign="top"><a id="a409745125b0b9dacce81c28aa4fa681f"></a>
typedef ssize_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a409745125b0b9dacce81c28aa4fa681f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd211efb9d4fb08f976ad0d8b68d477"><td class="memItemLeft" align="right" valign="top"><a id="afcd211efb9d4fb08f976ad0d8b68d477"></a>
typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:afcd211efb9d4fb08f976ad0d8b68d477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcf757bc862f27bbb47c186d1f4f3d5"><td class="memItemLeft" align="right" valign="top"><a id="adfcf757bc862f27bbb47c186d1f4f3d5"></a>
typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:adfcf757bc862f27bbb47c186d1f4f3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6a58fe177e25cf5ff2fba1d24cafed"><td class="memItemLeft" align="right" valign="top"><a id="aeb6a58fe177e25cf5ff2fba1d24cafed"></a>
typedef T *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:aeb6a58fe177e25cf5ff2fba1d24cafed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36415a3af69f10ea508f92890da1953f"><td class="memItemLeft" align="right" valign="top"><a id="a36415a3af69f10ea508f92890da1953f"></a>
typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:a36415a3af69f10ea508f92890da1953f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac148751115b8270f7741762fcf7448a4"><td class="memItemLeft" align="right" valign="top"><a id="ac148751115b8270f7741762fcf7448a4"></a>
typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a></td></tr>
<tr class="memdesc:ac148751115b8270f7741762fcf7448a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators are simple pointers to the data. <br /></td></tr>
<tr class="separator:ac148751115b8270f7741762fcf7448a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c453722d33eaacc79667e44753bfcf"><td class="memItemLeft" align="right" valign="top"><a id="ae2c453722d33eaacc79667e44753bfcf"></a>
typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a></td></tr>
<tr class="memdesc:ae2c453722d33eaacc79667e44753bfcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators are simple pointers to the data. <br /></td></tr>
<tr class="separator:ae2c453722d33eaacc79667e44753bfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a273832d0065ab15fd4f831a625360bbb"><td class="memItemLeft" align="right" valign="top"><a id="a273832d0065ab15fd4f831a625360bbb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a273832d0065ab15fd4f831a625360bbb">vector</a> () noexcept</td></tr>
<tr class="memdesc:a273832d0065ab15fd4f831a625360bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor, creates empty vector, maximum growth is 128k elements <br /></td></tr>
<tr class="separator:a273832d0065ab15fd4f831a625360bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2b844a416da34a87322e408fc71f81"><td class="memItemLeft" align="right" valign="top"><a id="a4e2b844a416da34a87322e408fc71f81"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a4e2b844a416da34a87322e408fc71f81">vector</a> (size_t count, const T &amp;value=T(), size_t max_grow_=131072)</td></tr>
<tr class="memdesc:a4e2b844a416da34a87322e408fc71f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor to create vector of given size and potentially set maximum growth size <br /></td></tr>
<tr class="separator:a4e2b844a416da34a87322e408fc71f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7932c6414d6dfce6b180b5733f0da4"><td class="memTemplParams" colspan="2"><a id="a9a7932c6414d6dfce6b180b5733f0da4"></a>
template&lt;class It , typename std::enable_if&lt; at_least_input_iterator&lt; It &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a9a7932c6414d6dfce6b180b5733f0da4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a9a7932c6414d6dfce6b180b5733f0da4">vector</a> (It first, It last, size_t max_grow_=131072)</td></tr>
<tr class="memdesc:a9a7932c6414d6dfce6b180b5733f0da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">contructor from iterators and optionally setting maximum growth size <br /></td></tr>
<tr class="separator:a9a7932c6414d6dfce6b180b5733f0da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f875406009b522f215daf9c955311e3"><td class="memItemLeft" align="right" valign="top"><a id="a3f875406009b522f215daf9c955311e3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a3f875406009b522f215daf9c955311e3">vector</a> (const <a class="el" href="classrealloc__vector_1_1vector.html">vector</a> &amp;v)</td></tr>
<tr class="memdesc:a3f875406009b522f215daf9c955311e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy and move constructors <br /></td></tr>
<tr class="separator:a3f875406009b522f215daf9c955311e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab933d4bae0c691339d004e20bfc85087"><td class="memItemLeft" align="right" valign="top"><a id="ab933d4bae0c691339d004e20bfc85087"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>vector</b> (<a class="el" href="classrealloc__vector_1_1vector.html">vector</a> &amp;&amp;v)</td></tr>
<tr class="separator:ab933d4bae0c691339d004e20bfc85087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c085aa276c39fbb9e8594662a6d120"><td class="memItemLeft" align="right" valign="top"><a id="ad1c085aa276c39fbb9e8594662a6d120"></a>
<a class="el" href="classrealloc__vector_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classrealloc__vector_1_1vector.html">vector</a> &amp;v)</td></tr>
<tr class="separator:ad1c085aa276c39fbb9e8594662a6d120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43465b6bb80432619db1c6f684868d79"><td class="memItemLeft" align="right" valign="top"><a id="a43465b6bb80432619db1c6f684868d79"></a>
<a class="el" href="classrealloc__vector_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classrealloc__vector_1_1vector.html">vector</a> &amp;&amp;v)</td></tr>
<tr class="separator:a43465b6bb80432619db1c6f684868d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e3cb8daca8b30aa44fba30840b38bb"><td class="memItemLeft" align="right" valign="top"><a id="a62e3cb8daca8b30aa44fba30840b38bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classrealloc__vector_1_1vector.html">vector</a> &amp;v)</td></tr>
<tr class="separator:a62e3cb8daca8b30aa44fba30840b38bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a585d0e284024569906e250be8861b"><td class="memItemLeft" align="right" valign="top"><a id="a30a585d0e284024569906e250be8861b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a30a585d0e284024569906e250be8861b">size</a> () const</td></tr>
<tr class="memdesc:a30a585d0e284024569906e250be8861b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current size, i.e. the number of elements stored in this vector. <br /></td></tr>
<tr class="separator:a30a585d0e284024569906e250be8861b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a3d50b008fbe0c9a91ce7c5ef5ffbd"><td class="memItemLeft" align="right" valign="top"><a id="ab1a3d50b008fbe0c9a91ce7c5ef5ffbd"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#ab1a3d50b008fbe0c9a91ce7c5ef5ffbd">capacity</a> () const</td></tr>
<tr class="memdesc:ab1a3d50b008fbe0c9a91ce7c5ef5ffbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current capacity, i.e. the number of elements that can be stored without allocating more memory. <br /></td></tr>
<tr class="separator:ab1a3d50b008fbe0c9a91ce7c5ef5ffbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d8fcc05e464f8a0036509a87977ff1"><td class="memItemLeft" align="right" valign="top"><a id="ac0d8fcc05e464f8a0036509a87977ff1"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#ac0d8fcc05e464f8a0036509a87977ff1">max_size</a> () const</td></tr>
<tr class="memdesc:ac0d8fcc05e464f8a0036509a87977ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size to avoid overflow when calculating memory size. <br /></td></tr>
<tr class="separator:ac0d8fcc05e464f8a0036509a87977ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dfeb04df3df39deb84ed66be2baea2"><td class="memItemLeft" align="right" valign="top"><a id="a91dfeb04df3df39deb84ed66be2baea2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a91dfeb04df3df39deb84ed66be2baea2">max_capacity</a> () const</td></tr>
<tr class="memdesc:a91dfeb04df3df39deb84ed66be2baea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum capacity to avoid overflow when calculating memory size. <br /></td></tr>
<tr class="separator:a91dfeb04df3df39deb84ed66be2baea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0767ab7c0741b4d65f727240d32eadaf"><td class="memItemLeft" align="right" valign="top"><a id="a0767ab7c0741b4d65f727240d32eadaf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a0767ab7c0741b4d65f727240d32eadaf">empty</a> () const</td></tr>
<tr class="memdesc:a0767ab7c0741b4d65f727240d32eadaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the vector is empty. <br /></td></tr>
<tr class="separator:a0767ab7c0741b4d65f727240d32eadaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895f5f7da09cb762ea67fa86e06f7665"><td class="memItemLeft" align="right" valign="top"><a id="a895f5f7da09cb762ea67fa86e06f7665"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a895f5f7da09cb762ea67fa86e06f7665">get_max_grow</a> () const</td></tr>
<tr class="memdesc:a895f5f7da09cb762ea67fa86e06f7665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum growth size. Memory is grown by this amount maximally. <br /></td></tr>
<tr class="separator:a895f5f7da09cb762ea67fa86e06f7665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572c38dae784011941b8d94aee4cb53d"><td class="memItemLeft" align="right" valign="top"><a id="a572c38dae784011941b8d94aee4cb53d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a572c38dae784011941b8d94aee4cb53d">set_max_grow</a> (size_t max_grow_)</td></tr>
<tr class="memdesc:a572c38dae784011941b8d94aee4cb53d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum growth size. Memory is grown by this amount maximally. <br /></td></tr>
<tr class="separator:a572c38dae784011941b8d94aee4cb53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc87b66298922eacf4f6dc94a802c9d6"><td class="memItemLeft" align="right" valign="top"><a id="afc87b66298922eacf4f6dc94a802c9d6"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#afc87b66298922eacf4f6dc94a802c9d6">data</a> ()</td></tr>
<tr class="memdesc:afc87b66298922eacf4f6dc94a802c9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the underlying array. <br /></td></tr>
<tr class="separator:afc87b66298922eacf4f6dc94a802c9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78bf26cb6801f7d2a68819f5ee8c11a"><td class="memItemLeft" align="right" valign="top"><a id="ad78bf26cb6801f7d2a68819f5ee8c11a"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#ad78bf26cb6801f7d2a68819f5ee8c11a">data</a> () const</td></tr>
<tr class="memdesc:ad78bf26cb6801f7d2a68819f5ee8c11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the underlying array. <br /></td></tr>
<tr class="separator:ad78bf26cb6801f7d2a68819f5ee8c11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dbb87b9a4d441b7b7f971d6d65d135"><td class="memItemLeft" align="right" valign="top"><a id="a96dbb87b9a4d441b7b7f971d6d65d135"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a96dbb87b9a4d441b7b7f971d6d65d135">operator[]</a> (size_t i)</td></tr>
<tr class="memdesc:a96dbb87b9a4d441b7b7f971d6d65d135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the ith element. It is undefined behavior to if i &gt;= <a class="el" href="classrealloc__vector_1_1vector.html#a30a585d0e284024569906e250be8861b" title="Current size, i.e. the number of elements stored in this vector. ">size()</a> <br /></td></tr>
<tr class="separator:a96dbb87b9a4d441b7b7f971d6d65d135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6545564739b10ee0558b377c8b45afe"><td class="memItemLeft" align="right" valign="top"><a id="ae6545564739b10ee0558b377c8b45afe"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#ae6545564739b10ee0558b377c8b45afe">operator[]</a> (size_t i) const</td></tr>
<tr class="memdesc:ae6545564739b10ee0558b377c8b45afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the ith element. It is undefined behavior to if i &gt;= <a class="el" href="classrealloc__vector_1_1vector.html#a30a585d0e284024569906e250be8861b" title="Current size, i.e. the number of elements stored in this vector. ">size()</a> <br /></td></tr>
<tr class="separator:ae6545564739b10ee0558b377c8b45afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cf4bbc7af68c30515c038b36bd6c70"><td class="memItemLeft" align="right" valign="top"><a id="ad9cf4bbc7af68c30515c038b36bd6c70"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#ad9cf4bbc7af68c30515c038b36bd6c70">at</a> (size_t i)</td></tr>
<tr class="memdesc:ad9cf4bbc7af68c30515c038b36bd6c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the ith element with bounds checking, throws an exception if i &gt;= <a class="el" href="classrealloc__vector_1_1vector.html#a30a585d0e284024569906e250be8861b" title="Current size, i.e. the number of elements stored in this vector. ">size()</a> <br /></td></tr>
<tr class="separator:ad9cf4bbc7af68c30515c038b36bd6c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f78e28d649dc467931b57a96cc8c7e"><td class="memItemLeft" align="right" valign="top"><a id="a03f78e28d649dc467931b57a96cc8c7e"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a03f78e28d649dc467931b57a96cc8c7e">at</a> (size_t i) const</td></tr>
<tr class="memdesc:a03f78e28d649dc467931b57a96cc8c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the ith element with bounds checking, throws an exception if i &gt;= <a class="el" href="classrealloc__vector_1_1vector.html#a30a585d0e284024569906e250be8861b" title="Current size, i.e. the number of elements stored in this vector. ">size()</a> <br /></td></tr>
<tr class="separator:a03f78e28d649dc467931b57a96cc8c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2820be824a7d9a1e228dd75ba68b9f"><td class="memItemLeft" align="right" valign="top"><a id="a4e2820be824a7d9a1e228dd75ba68b9f"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a4e2820be824a7d9a1e228dd75ba68b9f">front</a> ()</td></tr>
<tr class="memdesc:a4e2820be824a7d9a1e228dd75ba68b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element. It is undefined behavior if this function is called on an empty vector. <br /></td></tr>
<tr class="separator:a4e2820be824a7d9a1e228dd75ba68b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77f627118974a275b70e9ecbda60c17"><td class="memItemLeft" align="right" valign="top"><a id="ad77f627118974a275b70e9ecbda60c17"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#ad77f627118974a275b70e9ecbda60c17">front</a> () const</td></tr>
<tr class="memdesc:ad77f627118974a275b70e9ecbda60c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element. It is undefined behavior if this function is called on an empty vector. <br /></td></tr>
<tr class="separator:ad77f627118974a275b70e9ecbda60c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f58db5df7229e96cac66991380a184"><td class="memItemLeft" align="right" valign="top"><a id="aa1f58db5df7229e96cac66991380a184"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#aa1f58db5df7229e96cac66991380a184">back</a> ()</td></tr>
<tr class="memdesc:aa1f58db5df7229e96cac66991380a184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element. It is undefined behavior if this function is called on an empty vector. <br /></td></tr>
<tr class="separator:aa1f58db5df7229e96cac66991380a184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbfef33cc9e5c286055b616dfab329f"><td class="memItemLeft" align="right" valign="top"><a id="a3bbfef33cc9e5c286055b616dfab329f"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a3bbfef33cc9e5c286055b616dfab329f">back</a> () const</td></tr>
<tr class="memdesc:a3bbfef33cc9e5c286055b616dfab329f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element. It is undefined behavior if this function is called on an empty vector. <br /></td></tr>
<tr class="separator:a3bbfef33cc9e5c286055b616dfab329f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb3e0e2d1daa4e1ecc562dadf5e95a7"><td class="memItemLeft" align="right" valign="top"><a id="a1bb3e0e2d1daa4e1ecc562dadf5e95a7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a1bb3e0e2d1daa4e1ecc562dadf5e95a7">reserve_nothrow</a> (size_t n)</td></tr>
<tr class="memdesc:a1bb3e0e2d1daa4e1ecc562dadf5e95a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve memory for at least n elements. Returns true if allocation was successfull, false otherwise. <br /></td></tr>
<tr class="separator:a1bb3e0e2d1daa4e1ecc562dadf5e95a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b4ff12f786db97e44684ad1d331e78"><td class="memItemLeft" align="right" valign="top"><a id="a22b4ff12f786db97e44684ad1d331e78"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a22b4ff12f786db97e44684ad1d331e78">reserve</a> (size_t n)</td></tr>
<tr class="memdesc:a22b4ff12f786db97e44684ad1d331e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve memory for at least n elements. Throws an exception if memory allocation is not successful. <br /></td></tr>
<tr class="separator:a22b4ff12f786db97e44684ad1d331e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7267c0b7d5850a62d42f982fe9865764"><td class="memItemLeft" align="right" valign="top"><a id="a7267c0b7d5850a62d42f982fe9865764"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a7267c0b7d5850a62d42f982fe9865764">shrink_to_fit</a> (size_t new_capacity=0)</td></tr>
<tr class="memdesc:a7267c0b7d5850a62d42f982fe9865764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free up unused memory. <br /></td></tr>
<tr class="separator:a7267c0b7d5850a62d42f982fe9865764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c4845ab4c0c70d947bccb9f34931e8"><td class="memItemLeft" align="right" valign="top"><a id="a93c4845ab4c0c70d947bccb9f34931e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a93c4845ab4c0c70d947bccb9f34931e8">push_back</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a93c4845ab4c0c70d947bccb9f34931e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert element at the end of the vector. Can throw an exception if memory allocation fails. <br /></td></tr>
<tr class="separator:a93c4845ab4c0c70d947bccb9f34931e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530f7c3e3b85954746eee2842171c0f9"><td class="memItemLeft" align="right" valign="top"><a id="a530f7c3e3b85954746eee2842171c0f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a530f7c3e3b85954746eee2842171c0f9">push_back</a> (T &amp;&amp;x)</td></tr>
<tr class="memdesc:a530f7c3e3b85954746eee2842171c0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert element at the end of the vector. Can throw an exception if memory allocation fails. <br /></td></tr>
<tr class="separator:a530f7c3e3b85954746eee2842171c0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f071a99d12b0a0a7e970deb6ed7c412"><td class="memTemplParams" colspan="2"><a id="a1f071a99d12b0a0a7e970deb6ed7c412"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a1f071a99d12b0a0a7e970deb6ed7c412"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a1f071a99d12b0a0a7e970deb6ed7c412">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a1f071a99d12b0a0a7e970deb6ed7c412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an element at the end of the vector. Can throw an exception if memory allocation fails. <br /></td></tr>
<tr class="separator:a1f071a99d12b0a0a7e970deb6ed7c412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9922c6f92dea9955624905d5a83d461c"><td class="memItemLeft" align="right" valign="top"><a id="a9922c6f92dea9955624905d5a83d461c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a9922c6f92dea9955624905d5a83d461c">push_back_nothrow</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a9922c6f92dea9955624905d5a83d461c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert element at the end of the vector. Does not throw exception, return value indicates if insert was successful. <br /></td></tr>
<tr class="separator:a9922c6f92dea9955624905d5a83d461c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f07acc67900ecb802fa0ee5952c00ff"><td class="memItemLeft" align="right" valign="top"><a id="a5f07acc67900ecb802fa0ee5952c00ff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a5f07acc67900ecb802fa0ee5952c00ff">push_back_nothrow</a> (T &amp;&amp;x)</td></tr>
<tr class="memdesc:a5f07acc67900ecb802fa0ee5952c00ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert element at the end of the vector. Does not throw exception, return value indicates if insert was successful. <br /></td></tr>
<tr class="separator:a5f07acc67900ecb802fa0ee5952c00ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c5a9c34854e75d6aeb1a025bd21c9a"><td class="memTemplParams" colspan="2"><a id="ab9c5a9c34854e75d6aeb1a025bd21c9a"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ab9c5a9c34854e75d6aeb1a025bd21c9a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#ab9c5a9c34854e75d6aeb1a025bd21c9a">emplace_back_nothrow</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab9c5a9c34854e75d6aeb1a025bd21c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an element at the end of the vector. Does not throw exception, return value indicates if insert was successful. <br /></td></tr>
<tr class="separator:ab9c5a9c34854e75d6aeb1a025bd21c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae386444446bcb819203a107545c091c3"><td class="memItemLeft" align="right" valign="top"><a id="ae386444446bcb819203a107545c091c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#ae386444446bcb819203a107545c091c3">clear</a> ()</td></tr>
<tr class="memdesc:ae386444446bcb819203a107545c091c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements; does not free up memory, use <a class="el" href="classrealloc__vector_1_1vector.html#a7267c0b7d5850a62d42f982fe9865764">shrink_to_fit()</a> for that. <br /></td></tr>
<tr class="separator:ae386444446bcb819203a107545c091c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00362b5484112607f6215e5c8d7587a"><td class="memItemLeft" align="right" valign="top"><a id="ae00362b5484112607f6215e5c8d7587a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#ae00362b5484112607f6215e5c8d7587a">pop_back</a> ()</td></tr>
<tr class="memdesc:ae00362b5484112607f6215e5c8d7587a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element; does not free up memory, use <a class="el" href="classrealloc__vector_1_1vector.html#a7267c0b7d5850a62d42f982fe9865764">shrink_to_fit()</a> for that. <br /></td></tr>
<tr class="separator:ae00362b5484112607f6215e5c8d7587a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f95e630549531e13a266a96d273613"><td class="memItemLeft" align="right" valign="top"><a id="ae3f95e630549531e13a266a96d273613"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#ae3f95e630549531e13a266a96d273613">resize_nothrow</a> (size_t count)</td></tr>
<tr class="memdesc:ae3f95e630549531e13a266a96d273613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize vector. If new size is larger than current size, new elements are default constructed. Does not throw exception on memory allocation error, return value indicates if resize was successful. <br /></td></tr>
<tr class="separator:ae3f95e630549531e13a266a96d273613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0196ec7c458ff1021a32ea2279103893"><td class="memItemLeft" align="right" valign="top"><a id="a0196ec7c458ff1021a32ea2279103893"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a0196ec7c458ff1021a32ea2279103893">resize_nothrow</a> (size_t count, const T &amp;x)</td></tr>
<tr class="memdesc:a0196ec7c458ff1021a32ea2279103893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize vector. If new size is larger than current size, new elements are inserted as copies of x. Does not throw exception on memory allocation error, return value indicates if resize was successful. <br /></td></tr>
<tr class="separator:a0196ec7c458ff1021a32ea2279103893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb446746395edb89fe8241a8622fd3a"><td class="memItemLeft" align="right" valign="top"><a id="a5eb446746395edb89fe8241a8622fd3a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a5eb446746395edb89fe8241a8622fd3a">resize</a> (size_t count)</td></tr>
<tr class="memdesc:a5eb446746395edb89fe8241a8622fd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize vector. If new size is larger than current size, new elements are default constructed. Can throw an exception on memory allocation error. <br /></td></tr>
<tr class="separator:a5eb446746395edb89fe8241a8622fd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809eae26de590babdd4462bba8b45244"><td class="memItemLeft" align="right" valign="top"><a id="a809eae26de590babdd4462bba8b45244"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a809eae26de590babdd4462bba8b45244">resize</a> (size_t count, const T &amp;x)</td></tr>
<tr class="memdesc:a809eae26de590babdd4462bba8b45244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize vector. If new size is larger than current size, new elements are inserted as copies of x. Can throw exception on memory allocation error. <br /></td></tr>
<tr class="separator:a809eae26de590babdd4462bba8b45244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942db0684dc918c9101a9514e0020719"><td class="memItemLeft" align="right" valign="top"><a id="a942db0684dc918c9101a9514e0020719"></a>
<a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a942db0684dc918c9101a9514e0020719">begin</a> ()</td></tr>
<tr class="memdesc:a942db0684dc918c9101a9514e0020719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to the beginning. <br /></td></tr>
<tr class="separator:a942db0684dc918c9101a9514e0020719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a415be3e33d554109bbbd469e60cedb"><td class="memItemLeft" align="right" valign="top"><a id="a3a415be3e33d554109bbbd469e60cedb"></a>
<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a3a415be3e33d554109bbbd469e60cedb">begin</a> () const</td></tr>
<tr class="memdesc:a3a415be3e33d554109bbbd469e60cedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to the beginning. <br /></td></tr>
<tr class="separator:a3a415be3e33d554109bbbd469e60cedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad063768050395b11d7261e9da8434c64"><td class="memItemLeft" align="right" valign="top"><a id="ad063768050395b11d7261e9da8434c64"></a>
<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#ad063768050395b11d7261e9da8434c64">cbegin</a> () const</td></tr>
<tr class="memdesc:ad063768050395b11d7261e9da8434c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to the beginning. <br /></td></tr>
<tr class="separator:ad063768050395b11d7261e9da8434c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be9fe6d1dc32f7cb0397b806a77ec8e"><td class="memItemLeft" align="right" valign="top"><a id="a9be9fe6d1dc32f7cb0397b806a77ec8e"></a>
<a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a9be9fe6d1dc32f7cb0397b806a77ec8e">end</a> ()</td></tr>
<tr class="memdesc:a9be9fe6d1dc32f7cb0397b806a77ec8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to the end. <br /></td></tr>
<tr class="separator:a9be9fe6d1dc32f7cb0397b806a77ec8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af171ca549a7cf3674ba2f6f100d77248"><td class="memItemLeft" align="right" valign="top"><a id="af171ca549a7cf3674ba2f6f100d77248"></a>
<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#af171ca549a7cf3674ba2f6f100d77248">end</a> () const</td></tr>
<tr class="memdesc:af171ca549a7cf3674ba2f6f100d77248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to the end. <br /></td></tr>
<tr class="separator:af171ca549a7cf3674ba2f6f100d77248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5e9ed399f251a301a1ff8ea4d59a4b"><td class="memItemLeft" align="right" valign="top"><a id="aba5e9ed399f251a301a1ff8ea4d59a4b"></a>
<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#aba5e9ed399f251a301a1ff8ea4d59a4b">cend</a> () const</td></tr>
<tr class="memdesc:aba5e9ed399f251a301a1ff8ea4d59a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to the end. <br /></td></tr>
<tr class="separator:aba5e9ed399f251a301a1ff8ea4d59a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8893ff7affbfc43d788beab587e8330"><td class="memItemLeft" align="right" valign="top"><a id="ae8893ff7affbfc43d788beab587e8330"></a>
<a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#ae8893ff7affbfc43d788beab587e8330">erase</a> (<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> pos)</td></tr>
<tr class="memdesc:ae8893ff7affbfc43d788beab587e8330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at the given position. <br /></td></tr>
<tr class="separator:ae8893ff7affbfc43d788beab587e8330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b894836ab446db7d9870654d561e4d"><td class="memItemLeft" align="right" valign="top"><a id="a30b894836ab446db7d9870654d561e4d"></a>
<a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a30b894836ab446db7d9870654d561e4d">erase</a> (<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> first, <a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> last)</td></tr>
<tr class="memdesc:a30b894836ab446db7d9870654d561e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements in the given range. <br /></td></tr>
<tr class="separator:a30b894836ab446db7d9870654d561e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2e285a3a802cb1740dbd3c22a114b9"><td class="memItemLeft" align="right" valign="top"><a id="acd2e285a3a802cb1740dbd3c22a114b9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#acd2e285a3a802cb1740dbd3c22a114b9">insert_nothrow</a> (<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> pos, <a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a> &amp;res, const T &amp;x)</td></tr>
<tr class="memdesc:acd2e285a3a802cb1740dbd3c22a114b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a copy of x at the given position. Does not throw an exception on memory allocation failure, the return value indicates if it was successful. The res iterator is updated to point to the inserted element if successful, otherwise it is not changed. <br /></td></tr>
<tr class="separator:acd2e285a3a802cb1740dbd3c22a114b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae031e8191715cf34c3c966d60c7fcf38"><td class="memItemLeft" align="right" valign="top"><a id="ae031e8191715cf34c3c966d60c7fcf38"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#ae031e8191715cf34c3c966d60c7fcf38">insert_nothrow</a> (<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> pos, <a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a> &amp;res, T &amp;&amp;x)</td></tr>
<tr class="memdesc:ae031e8191715cf34c3c966d60c7fcf38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts x at the given position. Does not throw an exception on memory allocation failure, the return value indicates if it was successful. The res iterator is updated to point to the inserted element if successful, otherwise it is not changed. <br /></td></tr>
<tr class="separator:ae031e8191715cf34c3c966d60c7fcf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abe0ba305dda94b7f0660267f112638"><td class="memItemLeft" align="right" valign="top"><a id="a9abe0ba305dda94b7f0660267f112638"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a9abe0ba305dda94b7f0660267f112638">insert_nothrow</a> (<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> pos, <a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a> &amp;res, size_t count, const T &amp;x)</td></tr>
<tr class="memdesc:a9abe0ba305dda94b7f0660267f112638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts count copies of x at the given position. Does not throw an exception on memory allocation failure, the return value indicates if it was successful. The res iterator is updated to point to the inserted element if successful, otherwise it is not changed. <br /></td></tr>
<tr class="separator:a9abe0ba305dda94b7f0660267f112638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ed274792d4acd8b595e278f78fe7b4"><td class="memTemplParams" colspan="2"><a id="a87ed274792d4acd8b595e278f78fe7b4"></a>
template&lt;class InputIt , typename std::enable_if&lt; at_least_input_iterator&lt; InputIt &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a87ed274792d4acd8b595e278f78fe7b4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a87ed274792d4acd8b595e278f78fe7b4">insert_nothrow</a> (<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> pos, <a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a> &amp;res, InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a87ed274792d4acd8b595e278f78fe7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the elements in the range [first,last) at pos. Does not throw an exception on memory allocation failure, the return value indicates if it was successful. The res iterator is updated to point to the inserted element if successful, otherwise it is not changed. <br /></td></tr>
<tr class="separator:a87ed274792d4acd8b595e278f78fe7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbe5b7b4ecdc1f3e4f071fc51add893"><td class="memItemLeft" align="right" valign="top"><a id="afdbe5b7b4ecdc1f3e4f071fc51add893"></a>
<a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#afdbe5b7b4ecdc1f3e4f071fc51add893">insert</a> (<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> pos, const T &amp;x)</td></tr>
<tr class="memdesc:afdbe5b7b4ecdc1f3e4f071fc51add893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a copy of x at pos. Can throw an exception if out of memory. <br /></td></tr>
<tr class="separator:afdbe5b7b4ecdc1f3e4f071fc51add893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f8d6574ee660b5f3ce03879868f7d2"><td class="memItemLeft" align="right" valign="top"><a id="a21f8d6574ee660b5f3ce03879868f7d2"></a>
<a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a21f8d6574ee660b5f3ce03879868f7d2">insert</a> (<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> pos, T &amp;&amp;x)</td></tr>
<tr class="memdesc:a21f8d6574ee660b5f3ce03879868f7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts x at pos. Can throw an exception if out of memory. <br /></td></tr>
<tr class="separator:a21f8d6574ee660b5f3ce03879868f7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f42682f74a5045f791358d6fb627c89"><td class="memItemLeft" align="right" valign="top"><a id="a8f42682f74a5045f791358d6fb627c89"></a>
<a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a8f42682f74a5045f791358d6fb627c89">insert</a> (<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> pos, size_t count, const T &amp;x)</td></tr>
<tr class="memdesc:a8f42682f74a5045f791358d6fb627c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts count copies of x at pos. Can throw an exception if out of memory. <br /></td></tr>
<tr class="separator:a8f42682f74a5045f791358d6fb627c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171d440a8c7744e3b4cbd14fef3a7baf"><td class="memTemplParams" colspan="2"><a id="a171d440a8c7744e3b4cbd14fef3a7baf"></a>
template&lt;class InputIt , typename std::enable_if&lt; at_least_input_iterator&lt; InputIt &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a171d440a8c7744e3b4cbd14fef3a7baf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a171d440a8c7744e3b4cbd14fef3a7baf">insert</a> (<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> pos, InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a171d440a8c7744e3b4cbd14fef3a7baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the elements in the range [first,last) at pos. Can throw an exception if out of memory. <br /></td></tr>
<tr class="separator:a171d440a8c7744e3b4cbd14fef3a7baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679b0732049cc2bd8ed9eada644d6bbd"><td class="memTemplParams" colspan="2"><a id="a679b0732049cc2bd8ed9eada644d6bbd"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a679b0732049cc2bd8ed9eada644d6bbd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_nothrow</b> (<a class="el" href="classrealloc__vector_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> pos, <a class="el" href="classrealloc__vector_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a> &amp;res, const T &amp;x)</td></tr>
<tr class="separator:a679b0732049cc2bd8ed9eada644d6bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52bf1656aa73e7008f8788284b1b6e2"><td class="memTemplParams" colspan="2"><a id="ab52bf1656aa73e7008f8788284b1b6e2"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:ab52bf1656aa73e7008f8788284b1b6e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_nothrow</b> (<a class="el" href="classrealloc__vector_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> pos, <a class="el" href="classrealloc__vector_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a> &amp;res, T &amp;&amp;x)</td></tr>
<tr class="separator:ab52bf1656aa73e7008f8788284b1b6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd3894bb588a28f0d7b1661f0c561e3"><td class="memTemplParams" colspan="2"><a id="a9fd3894bb588a28f0d7b1661f0c561e3"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a9fd3894bb588a28f0d7b1661f0c561e3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_nothrow</b> (<a class="el" href="classrealloc__vector_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> pos, <a class="el" href="classrealloc__vector_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a> &amp;res, size_t count, const T &amp;x)</td></tr>
<tr class="separator:a9fd3894bb588a28f0d7b1661f0c561e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bdad7a27ca8c407d588a19b1d016db"><td class="memTemplParams" colspan="2"><a id="af2bdad7a27ca8c407d588a19b1d016db"></a>
template&lt;class InputIt , typename std::enable_if&lt; at_least_input_iterator&lt; InputIt &gt;::value, int &gt;::type &gt; </td></tr>
<tr class="memitem:af2bdad7a27ca8c407d588a19b1d016db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_nothrow</b> (<a class="el" href="classrealloc__vector_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> pos, <a class="el" href="classrealloc__vector_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a> &amp;res, InputIt first, InputIt last)</td></tr>
<tr class="separator:af2bdad7a27ca8c407d588a19b1d016db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5323b444f91ea398b9c02a1defb71b"><td class="memTemplParams" colspan="2"><a id="a8f5323b444f91ea398b9c02a1defb71b"></a>
template&lt;class T , template&lt; class &gt; class vt&gt; </td></tr>
<tr class="memitem:a8f5323b444f91ea398b9c02a1defb71b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vector</b> (const <a class="el" href="classrealloc__vector_1_1vector.html">vector</a>&lt; T, vt &gt; &amp;v)</td></tr>
<tr class="separator:a8f5323b444f91ea398b9c02a1defb71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7470034531a910ae894917503bc226"><td class="memTemplParams" colspan="2"><a id="a8e7470034531a910ae894917503bc226"></a>
template&lt;class T , template&lt; class &gt; class vt&gt; </td></tr>
<tr class="memitem:a8e7470034531a910ae894917503bc226"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vector</b> (<a class="el" href="classrealloc__vector_1_1vector.html">vector</a>&lt; T, vt &gt; &amp;&amp;v)</td></tr>
<tr class="separator:a8e7470034531a910ae894917503bc226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ca6e690ff5a435ff3e1ab4febdb57a"><td class="memTemplParams" colspan="2"><a id="aa8ca6e690ff5a435ff3e1ab4febdb57a"></a>
template&lt;class T , template&lt; class &gt; class vt&gt; </td></tr>
<tr class="memitem:aa8ca6e690ff5a435ff3e1ab4febdb57a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_nothrow</b> (<a class="el" href="classrealloc__vector_1_1vector.html">vector</a>&lt; T, vt &gt;::<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> pos, <a class="el" href="classrealloc__vector_1_1vector.html">vector</a>&lt; T, vt &gt;::<a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a> &amp;res, const T &amp;x)</td></tr>
<tr class="separator:aa8ca6e690ff5a435ff3e1ab4febdb57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0374cd041f0cc73888953ecefa88ce50"><td class="memTemplParams" colspan="2"><a id="a0374cd041f0cc73888953ecefa88ce50"></a>
template&lt;class T , template&lt; class &gt; class vt&gt; </td></tr>
<tr class="memitem:a0374cd041f0cc73888953ecefa88ce50"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_nothrow</b> (<a class="el" href="classrealloc__vector_1_1vector.html">vector</a>&lt; T, vt &gt;::<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> pos, <a class="el" href="classrealloc__vector_1_1vector.html">vector</a>&lt; T, vt &gt;::<a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a> &amp;res, T &amp;&amp;x)</td></tr>
<tr class="separator:a0374cd041f0cc73888953ecefa88ce50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28506e28b674695398c57b62687296fb"><td class="memTemplParams" colspan="2"><a id="a28506e28b674695398c57b62687296fb"></a>
template&lt;class T , template&lt; class &gt; class vt&gt; </td></tr>
<tr class="memitem:a28506e28b674695398c57b62687296fb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_nothrow</b> (<a class="el" href="classrealloc__vector_1_1vector.html">vector</a>&lt; T, vt &gt;::<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> pos, <a class="el" href="classrealloc__vector_1_1vector.html">vector</a>&lt; T, vt &gt;::<a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a> &amp;res, size_t count, const T &amp;x)</td></tr>
<tr class="separator:a28506e28b674695398c57b62687296fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb7bca15edbd05c535a153c094e7ef4"><td class="memTemplParams" colspan="2"><a id="a8cb7bca15edbd05c535a153c094e7ef4"></a>
template&lt;class InputIt , typename std::enable_if&lt; at_least_input_iterator&lt; InputIt &gt;::value, int &gt;::type &gt; </td></tr>
<tr class="memitem:a8cb7bca15edbd05c535a153c094e7ef4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_nothrow</b> (<a class="el" href="classrealloc__vector_1_1vector.html">vector</a>&lt; T, vt &gt;::<a class="el" href="classrealloc__vector_1_1vector.html#ae2c453722d33eaacc79667e44753bfcf">const_iterator</a> pos, <a class="el" href="classrealloc__vector_1_1vector.html">vector</a>&lt; T, vt &gt;::<a class="el" href="classrealloc__vector_1_1vector.html#ac148751115b8270f7741762fcf7448a4">iterator</a> &amp;res, InputIt first, InputIt last)</td></tr>
<tr class="separator:a8cb7bca15edbd05c535a153c094e7ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af8d67540abd9754e9c10028b26efd551"><td class="memItemLeft" align="right" valign="top"><a id="af8d67540abd9754e9c10028b26efd551"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#af8d67540abd9754e9c10028b26efd551">change_size</a> (size_t new_size)</td></tr>
<tr class="memdesc:af8d67540abd9754e9c10028b26efd551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate memory to the given new size. <br /></td></tr>
<tr class="separator:af8d67540abd9754e9c10028b26efd551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6d8cfde59860361d6a04ddd06c51ef"><td class="memItemLeft" align="right" valign="top"><a id="abd6d8cfde59860361d6a04ddd06c51ef"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#abd6d8cfde59860361d6a04ddd06c51ef">grow_vector</a> (size_t minimum_size=0)</td></tr>
<tr class="memdesc:abd6d8cfde59860361d6a04ddd06c51ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to grow vector either to the given minimum size or by doubling the current size unless growth would be larger than max_grow, in which case size is increased by max_grow. <br /></td></tr>
<tr class="separator:abd6d8cfde59860361d6a04ddd06c51ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9413d0dbcfb634e4dc52e3bf938df006"><td class="memItemLeft" align="right" valign="top"><a id="a9413d0dbcfb634e4dc52e3bf938df006"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>insert_helper</b> (size_t pos, size_t new_pos)</td></tr>
<tr class="separator:a9413d0dbcfb634e4dc52e3bf938df006"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1f2b3f7f5512a6c351decc5cb00011cf"><td class="memItemLeft" align="right" valign="top"><a id="a1f2b3f7f5512a6c351decc5cb00011cf"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a1f2b3f7f5512a6c351decc5cb00011cf">start</a></td></tr>
<tr class="memdesc:a1f2b3f7f5512a6c351decc5cb00011cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to elements <br /></td></tr>
<tr class="separator:a1f2b3f7f5512a6c351decc5cb00011cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f81f13f11c436cca8530a85a067120"><td class="memItemLeft" align="right" valign="top"><a id="a21f81f13f11c436cca8530a85a067120"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a21f81f13f11c436cca8530a85a067120">p_size</a></td></tr>
<tr class="memdesc:a21f81f13f11c436cca8530a85a067120"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of elements in vector <br /></td></tr>
<tr class="separator:a21f81f13f11c436cca8530a85a067120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c73e1b6bfdfbd0210ab7d15f2faea0"><td class="memItemLeft" align="right" valign="top"><a id="a73c73e1b6bfdfbd0210ab7d15f2faea0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a73c73e1b6bfdfbd0210ab7d15f2faea0">p_capacity</a></td></tr>
<tr class="memdesc:a73c73e1b6bfdfbd0210ab7d15f2faea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">current capacity of vector <br /></td></tr>
<tr class="separator:a73c73e1b6bfdfbd0210ab7d15f2faea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef27a1824977a55a97da0381f5610108"><td class="memItemLeft" align="right" valign="top"><a id="aef27a1824977a55a97da0381f5610108"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#aef27a1824977a55a97da0381f5610108">max_grow</a></td></tr>
<tr class="memdesc:aef27a1824977a55a97da0381f5610108"><td class="mdescLeft">&#160;</td><td class="mdescRight">grow memory by maximum this many elements at a time <br /></td></tr>
<tr class="separator:aef27a1824977a55a97da0381f5610108"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a5fac87b1ba96b79b01df865f0c1b02f6"><td class="memItemLeft" align="right" valign="top"><a id="a5fac87b1ba96b79b01df865f0c1b02f6"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealloc__vector_1_1vector.html#a5fac87b1ba96b79b01df865f0c1b02f6">p_max_capacity</a> = std::numeric_limits&lt;size_t&gt;::max() / sizeof(T)</td></tr>
<tr class="memdesc:a5fac87b1ba96b79b01df865f0c1b02f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum safe capacity to avoid overflow <br /></td></tr>
<tr class="separator:a5fac87b1ba96b79b01df865f0c1b02f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class realloc_vector::vector&lt; T &gt;</h3>

<p>C++ vector-like container for trivially moveable types, using realloc() for growing memory, with limits on maximum absolute growth. </p>
<p>Main motivation for this class are the following perceived issues with std::vector:</p>
<ol type="1">
<li>An std::vector always grows by a fixed factor (typically 2, i.e. doubling capacity on most implementations). This is required to avoid O(n^2) copies of elements if growing a vector requires copying all elements (see below). Thus, if a vector is full with N elements, memory requirement jumps up to 2*N, which might end up wasting memory space.</li>
<li>Since the stored type in std::vector is not necessarily trivially copyable (cannot be moved with memcopy() / memmove()), any change in capacity needs to be performed in three steps: 1. allocate new memory; 2. copy elements; 3. free previous memory. This way, it is not possible to use any optimizations offered by realloc() (e.g. using mremap() on Linux for large allocations). Growing a vector of size N then actually requires allocating memory in total for 3*N elements, and using 2*N elements of it for the duration of the grow.</li>
</ol>
<p>This class addresses these issues by requiring the stored type to be trivially copyable, thus realloc() can be used for changing the size. Using the assumption that realloc() is optimized for large memory areas to avoid a copy, this will result in the memory requirement being only the requested new size. This also allows the vector to be grown in smaller chunks that can be useful to avoid getting an out of memory error.</p>
<p>Currently, the requirement is for the type to be trivially copyable (as per std::is_trivially_copyable), but it could be relaxed to any type that can be moved by a simple memmove() (and not calling the destructor explicitly), i.e. any type that allocates dynamic memory as well, as long as it does not store a pointer to itself (and no pointers to it are stored elsewhere as well). </p>
</div><hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="vector__realloc_8h_source.html">vector_realloc.h</a></li>
<li><a class="el" href="vector__stacked_8h_source.html">vector_stacked.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
