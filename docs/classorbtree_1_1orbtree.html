<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>orbtree: orbtree::orbtree&lt; NodeAllocator, Compare, NVFunc, multi &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">orbtree
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>orbtree</b></li><li class="navelem"><a class="el" href="classorbtree_1_1orbtree.html">orbtree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classorbtree_1_1orbtree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">orbtree::orbtree&lt; NodeAllocator, Compare, NVFunc, multi &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Generalized order statistic tree main interface. It is recommended to use the templates <a class="el" href="classorbtree_1_1orbset.html">orbset</a>, <a class="el" href="classorbtree_1_1orbsetC.html" title="Specialized set with compact storage, for POD (trivially copyable) elements. See orbtree::orbtree for...">orbsetC</a>, <a class="el" href="classorbtree_1_1orbmultiset.html">orbmultiset</a>, <a class="el" href="classorbtree_1_1orbmultisetC.html" title="Specialized multiset with compact storage, for POD (trivially copyable) elements. See orbtree::orbtre...">orbmultisetC</a>, <a class="el" href="classorbtree_1_1orbmap.html">orbmap</a>, <a class="el" href="classorbtree_1_1orbmapC.html" title="Map implementation with compact storage. See orbtree and orbtreemap for description of members...">orbmapC</a>, <a class="el" href="classorbtree_1_1orbmultimap.html">orbmultimap</a> and <a class="el" href="classorbtree_1_1orbmultimapC.html" title="Multimap implementation with compact storage. See orbtree for description of members. Key and value must be POD-types. ">orbmultimapC</a> to instantiate various versions instead of directly using this class template.  
 <a href="classorbtree_1_1orbtree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="orbtree_8h_source.html">orbtree.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for orbtree::orbtree&lt; NodeAllocator, Compare, NVFunc, multi &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classorbtree_1_1orbtree__inherit__graph.png" border="0" usemap="#orbtree_1_1orbtree_3_01NodeAllocator_00_01Compare_00_01NVFunc_00_01multi_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="orbtree_1_1orbtree_3_01NodeAllocator_00_01Compare_00_01NVFunc_00_01multi_01_4_inherit__map" id="orbtree_1_1orbtree_3_01NodeAllocator_00_01Compare_00_01NVFunc_00_01multi_01_4_inherit__map">
<area shape="rect" id="node2" href="classorbtree_1_1orbtree__base.html" title="base class for both map and set – should not be used directly " alt="" coords="19,80,200,136"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for orbtree::orbtree&lt; NodeAllocator, Compare, NVFunc, multi &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classorbtree_1_1orbtree__coll__graph.png" border="0" usemap="#orbtree_1_1orbtree_3_01NodeAllocator_00_01Compare_00_01NVFunc_00_01multi_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="orbtree_1_1orbtree_3_01NodeAllocator_00_01Compare_00_01NVFunc_00_01multi_01_4_coll__map" id="orbtree_1_1orbtree_3_01NodeAllocator_00_01Compare_00_01NVFunc_00_01multi_01_4_coll__map">
<area shape="rect" id="node2" href="classorbtree_1_1orbtree__base.html" title="base class for both map and set – should not be used directly " alt="" coords="80,95,261,151"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structorbtree_1_1orbtree_1_1iterator__base.html">iterator_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators.  <a href="structorbtree_1_1orbtree_1_1iterator__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a881f04f49d41692ff98d8bda444f9a43"><td class="memItemLeft" align="right" valign="top"><a id="a881f04f49d41692ff98d8bda444f9a43"></a>
typedef NodeAllocator::KeyValue::ValueType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a881f04f49d41692ff98d8bda444f9a43">value_type</a></td></tr>
<tr class="memdesc:a881f04f49d41692ff98d8bda444f9a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values stored in this tree. Either the key (for sets) or an std::pair or <a class="el" href="structorbtree_1_1trivial__pair.html" title="trivially copyable pair, similar to std::pair ">orbtree::trivial_pair</a> of key and value. <br /></td></tr>
<tr class="separator:a881f04f49d41692ff98d8bda444f9a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872823d333cf4224dedb47015117858e"><td class="memItemLeft" align="right" valign="top"><a id="a872823d333cf4224dedb47015117858e"></a>
typedef NodeAllocator::KeyValue::KeyType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a872823d333cf4224dedb47015117858e">key_type</a></td></tr>
<tr class="memdesc:a872823d333cf4224dedb47015117858e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type of nodes that determines ordering. <br /></td></tr>
<tr class="separator:a872823d333cf4224dedb47015117858e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c62695054716e369a4a9e370d5afb0"><td class="memItemLeft" align="right" valign="top"><a id="a67c62695054716e369a4a9e370d5afb0"></a>
typedef NodeAllocator::NVType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a67c62695054716e369a4a9e370d5afb0">NVType</a></td></tr>
<tr class="memdesc:a67c62695054716e369a4a9e370d5afb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of values associated by nodes (calculated by NVFunc) <br /></td></tr>
<tr class="separator:a67c62695054716e369a4a9e370d5afb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416e9f04eda0169191de92135d036d21"><td class="memItemLeft" align="right" valign="top"><a id="a416e9f04eda0169191de92135d036d21"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a416e9f04eda0169191de92135d036d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad38bd35671926a99383f3c0c720809a"><td class="memItemLeft" align="right" valign="top"><a id="aad38bd35671926a99383f3c0c720809a"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:aad38bd35671926a99383f3c0c720809a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdfea1e7580d7c43ad8d62816c9461e"><td class="memItemLeft" align="right" valign="top"><a id="a2bdfea1e7580d7c43ad8d62816c9461e"></a>
typedef <a class="el" href="structorbtree_1_1orbtree_1_1iterator__base.html">iterator_base</a>&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a></td></tr>
<tr class="memdesc:a2bdfea1e7580d7c43ad8d62816c9461e"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator that does not allow modification <br /></td></tr>
<tr class="separator:a2bdfea1e7580d7c43ad8d62816c9461e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae617d1a2aca440829f85d16cf97a0a6f"><td class="memItemLeft" align="right" valign="top"><a id="ae617d1a2aca440829f85d16cf97a0a6f"></a>
typedef std::conditional&lt; NodeAllocator::KeyValue::keyonly, <a class="el" href="structorbtree_1_1orbtree_1_1iterator__base.html">iterator_base</a>&lt; true &gt;, <a class="el" href="structorbtree_1_1orbtree_1_1iterator__base.html">iterator_base</a>&lt; false &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a></td></tr>
<tr class="memdesc:ae617d1a2aca440829f85d16cf97a0a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">iteraror that allows the modification of the stored value (for maps) <br /></td></tr>
<tr class="separator:ae617d1a2aca440829f85d16cf97a0a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552618d05b82e96fe8914eb484ebed09"><td class="memItemLeft" align="right" valign="top"><a id="a552618d05b82e96fe8914eb484ebed09"></a>
typedef std::conditional&lt; multi, <a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a>, std::pair&lt; <a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a>, bool &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a552618d05b82e96fe8914eb484ebed09">insert_type</a></td></tr>
<tr class="memdesc:a552618d05b82e96fe8914eb484ebed09"><td class="mdescLeft">&#160;</td><td class="mdescRight">return type of insert functions <br /></td></tr>
<tr class="separator:a552618d05b82e96fe8914eb484ebed09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classorbtree_1_1orbtree__base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classorbtree_1_1orbtree__base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base&lt; NodeAllocator, Compare, NVFunc, multi &gt;</a></td></tr>
<tr class="memitem:ad94ad812f92bd1f2f156d6140a2833a0 inherit pub_types_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="ad94ad812f92bd1f2f156d6140a2833a0"></a>
typedef NodeAllocator::NVType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a></td></tr>
<tr class="memdesc:ad94ad812f92bd1f2f156d6140a2833a0 inherit pub_types_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type the function NVFunc returns. <br /></td></tr>
<tr class="separator:ad94ad812f92bd1f2f156d6140a2833a0 inherit pub_types_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acd65a4f59d8839b0ea16d1ca963e3252"><td class="memItemLeft" align="right" valign="top"><a id="acd65a4f59d8839b0ea16d1ca963e3252"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>orbtree</b> (const NVFunc &amp;f_=NVFunc(), const Compare &amp;c_=Compare())</td></tr>
<tr class="separator:acd65a4f59d8839b0ea16d1ca963e3252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6deb79db2818d6143ab3d252622d5b63"><td class="memItemLeft" align="right" valign="top"><a id="a6deb79db2818d6143ab3d252622d5b63"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>orbtree</b> (NVFunc &amp;&amp;f_, const Compare &amp;c_=Compare())</td></tr>
<tr class="separator:a6deb79db2818d6143ab3d252622d5b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297c7fadc71d0f72be189f4dae83b393"><td class="memItemLeft" align="right" valign="top"><a id="a297c7fadc71d0f72be189f4dae83b393"></a>
<a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="separator:a297c7fadc71d0f72be189f4dae83b393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc43ed1fcb980c462fc11b3874f655a"><td class="memItemLeft" align="right" valign="top"><a id="adbc43ed1fcb980c462fc11b3874f655a"></a>
<a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#adbc43ed1fcb980c462fc11b3874f655a">begin</a> () const</td></tr>
<tr class="memdesc:adbc43ed1fcb980c462fc11b3874f655a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get an iterator to the beginning (node with the lowest key value) <br /></td></tr>
<tr class="separator:adbc43ed1fcb980c462fc11b3874f655a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029ef970c1de50bc780920eb27c76048"><td class="memItemLeft" align="right" valign="top"><a id="a029ef970c1de50bc780920eb27c76048"></a>
<a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a029ef970c1de50bc780920eb27c76048">cbegin</a> () const</td></tr>
<tr class="memdesc:a029ef970c1de50bc780920eb27c76048"><td class="mdescLeft">&#160;</td><td class="mdescRight">get an iterator to the beginning (node with the lowest key value) <br /></td></tr>
<tr class="separator:a029ef970c1de50bc780920eb27c76048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89be1362c0950f04cbf3645ad450d02e"><td class="memItemLeft" align="right" valign="top"><a id="a89be1362c0950f04cbf3645ad450d02e"></a>
<a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a89be1362c0950f04cbf3645ad450d02e">end</a> ()</td></tr>
<tr class="memdesc:a89be1362c0950f04cbf3645ad450d02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get an iterator to the beginning (node with the lowest key value) <br /></td></tr>
<tr class="separator:a89be1362c0950f04cbf3645ad450d02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d720db76ba0bda866c443a2aa85b38"><td class="memItemLeft" align="right" valign="top"><a id="ac1d720db76ba0bda866c443a2aa85b38"></a>
<a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#ac1d720db76ba0bda866c443a2aa85b38">end</a> () const</td></tr>
<tr class="memdesc:ac1d720db76ba0bda866c443a2aa85b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the past-the-end iterator <br /></td></tr>
<tr class="separator:ac1d720db76ba0bda866c443a2aa85b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5551d9455cd683bb9b5a977b259db14a"><td class="memItemLeft" align="right" valign="top"><a id="a5551d9455cd683bb9b5a977b259db14a"></a>
<a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a5551d9455cd683bb9b5a977b259db14a">cend</a> () const</td></tr>
<tr class="memdesc:a5551d9455cd683bb9b5a977b259db14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the past-the-end iterator <br /></td></tr>
<tr class="separator:a5551d9455cd683bb9b5a977b259db14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8dbc984390fc4504530929281bef04e"><td class="memItemLeft" align="right" valign="top"><a id="ab8dbc984390fc4504530929281bef04e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#ab8dbc984390fc4504530929281bef04e">empty</a> () const</td></tr>
<tr class="memdesc:ab8dbc984390fc4504530929281bef04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the past-the-end iterator <br /></td></tr>
<tr class="separator:ab8dbc984390fc4504530929281bef04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075e580c4008a5099132e15d5f0b52c6"><td class="memItemLeft" align="right" valign="top"><a id="a075e580c4008a5099132e15d5f0b52c6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a075e580c4008a5099132e15d5f0b52c6">size</a> () const</td></tr>
<tr class="memdesc:a075e580c4008a5099132e15d5f0b52c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if the tree is empty <br /></td></tr>
<tr class="separator:a075e580c4008a5099132e15d5f0b52c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0d0269732f7b8d9a699789bc615587"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a1c0d0269732f7b8d9a699789bc615587">max_size</a> () const</td></tr>
<tr class="memdesc:a1c0d0269732f7b8d9a699789bc615587"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the maximum possible number of elements  <a href="#a1c0d0269732f7b8d9a699789bc615587">More...</a><br /></td></tr>
<tr class="separator:a1c0d0269732f7b8d9a699789bc615587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfda6c14a1a6370843a46a196107f528"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree.html#a552618d05b82e96fe8914eb484ebed09">insert_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#adfda6c14a1a6370843a46a196107f528">insert</a> (const <a class="el" href="classorbtree_1_1orbtree.html#a881f04f49d41692ff98d8bda444f9a43">value_type</a> &amp;v)</td></tr>
<tr class="memdesc:adfda6c14a1a6370843a46a196107f528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new element.  <a href="#adfda6c14a1a6370843a46a196107f528">More...</a><br /></td></tr>
<tr class="separator:adfda6c14a1a6370843a46a196107f528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced8846c22739f2af9f3b8d14311d406"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree.html#a552618d05b82e96fe8914eb484ebed09">insert_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#aced8846c22739f2af9f3b8d14311d406">insert</a> (<a class="el" href="classorbtree_1_1orbtree.html#a881f04f49d41692ff98d8bda444f9a43">value_type</a> &amp;&amp;v)</td></tr>
<tr class="memdesc:aced8846c22739f2af9f3b8d14311d406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new element.  <a href="#aced8846c22739f2af9f3b8d14311d406">More...</a><br /></td></tr>
<tr class="separator:aced8846c22739f2af9f3b8d14311d406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7431e41d04a66f8d2859dc943c9e8073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a7431e41d04a66f8d2859dc943c9e8073">insert</a> (<a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a> hint, const <a class="el" href="classorbtree_1_1orbtree.html#a881f04f49d41692ff98d8bda444f9a43">value_type</a> &amp;v)</td></tr>
<tr class="memdesc:a7431e41d04a66f8d2859dc943c9e8073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new element with hint.  <a href="#a7431e41d04a66f8d2859dc943c9e8073">More...</a><br /></td></tr>
<tr class="separator:a7431e41d04a66f8d2859dc943c9e8073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac032f9edef7bb64542a59c365732965e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#ac032f9edef7bb64542a59c365732965e">insert</a> (<a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a> hint, <a class="el" href="classorbtree_1_1orbtree.html#a881f04f49d41692ff98d8bda444f9a43">value_type</a> &amp;&amp;v)</td></tr>
<tr class="memdesc:ac032f9edef7bb64542a59c365732965e"><td class="mdescLeft">&#160;</td><td class="mdescRight">iteraror that allows the modification of the stored value (for maps) <a class="el" href="classorbtree_1_1orbtree.html#a7431e41d04a66f8d2859dc943c9e8073" title="Insert new element with hint. ">insert(const_iterator hint, const value_type&amp; v)</a>  <a href="#ac032f9edef7bb64542a59c365732965e">More...</a><br /></td></tr>
<tr class="separator:ac032f9edef7bb64542a59c365732965e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add356a0f9982ba3977c3742ffa6e4ecc"><td class="memTemplParams" colspan="2"><a id="add356a0f9982ba3977c3742ffa6e4ecc"></a>
template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:add356a0f9982ba3977c3742ffa6e4ecc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#add356a0f9982ba3977c3742ffa6e4ecc">insert</a> (InputIt <a class="el" href="classorbtree_1_1orbtree__base.html#a0c92f44eef353e6feea10b24647a6850">first</a>, InputIt <a class="el" href="classorbtree_1_1orbtree__base.html#a5478426317ce688d2c1a3ecf33efdc7a">last</a>)</td></tr>
<tr class="memdesc:add356a0f9982ba3977c3742ffa6e4ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert all elements in the range [first,last) <br /></td></tr>
<tr class="separator:add356a0f9982ba3977c3742ffa6e4ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe02e5aa9e9988b75b5d5ef3e74b3b8a"><td class="memTemplParams" colspan="2"><a id="abe02e5aa9e9988b75b5d5ef3e74b3b8a"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:abe02e5aa9e9988b75b5d5ef3e74b3b8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree.html#a552618d05b82e96fe8914eb484ebed09">insert_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#abe02e5aa9e9988b75b5d5ef3e74b3b8a">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:abe02e5aa9e9988b75b5d5ef3e74b3b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct new element in-place <br /></td></tr>
<tr class="separator:abe02e5aa9e9988b75b5d5ef3e74b3b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68c87a1a13357afcab3b98148637cd8"><td class="memTemplParams" colspan="2"><a id="ac68c87a1a13357afcab3b98148637cd8"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ac68c87a1a13357afcab3b98148637cd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#ac68c87a1a13357afcab3b98148637cd8">emplace_hint</a> (<a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a> hint, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac68c87a1a13357afcab3b98148637cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct new element in-place, using the given hint in a same way as <a class="el" href="classorbtree_1_1orbtree.html#adfda6c14a1a6370843a46a196107f528" title="Insert new element. ">insert()</a> with a hint <br /></td></tr>
<tr class="separator:ac68c87a1a13357afcab3b98148637cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b56dddd65d28a3cdf0c9d89f0b4798a"><td class="memItemLeft" align="right" valign="top"><a id="a6b56dddd65d28a3cdf0c9d89f0b4798a"></a>
<a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a6b56dddd65d28a3cdf0c9d89f0b4798a">erase</a> (<a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a> pos)</td></tr>
<tr class="memdesc:a6b56dddd65d28a3cdf0c9d89f0b4798a"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase element pointed to by the given iterator; returns the element after it (in order) <br /></td></tr>
<tr class="separator:a6b56dddd65d28a3cdf0c9d89f0b4798a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7604a44fbd6f6d56397f9b572d704175"><td class="memItemLeft" align="right" valign="top"><a id="a7604a44fbd6f6d56397f9b572d704175"></a>
<a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a7604a44fbd6f6d56397f9b572d704175">erase</a> (<a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a> <a class="el" href="classorbtree_1_1orbtree__base.html#a0c92f44eef353e6feea10b24647a6850">first</a>, <a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a> <a class="el" href="classorbtree_1_1orbtree__base.html#a5478426317ce688d2c1a3ecf33efdc7a">last</a>)</td></tr>
<tr class="memdesc:a7604a44fbd6f6d56397f9b572d704175"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase elements in the range [first,last); returns last <br /></td></tr>
<tr class="separator:a7604a44fbd6f6d56397f9b572d704175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb9db61d8aaceb0bcfac0c84b4f2cac"><td class="memItemLeft" align="right" valign="top"><a id="accb9db61d8aaceb0bcfac0c84b4f2cac"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#accb9db61d8aaceb0bcfac0c84b4f2cac">erase</a> (const <a class="el" href="classorbtree_1_1orbtree.html#a872823d333cf4224dedb47015117858e">key_type</a> &amp;k)</td></tr>
<tr class="memdesc:accb9db61d8aaceb0bcfac0c84b4f2cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase all elements with the given key; returns the number of elements erased <br /></td></tr>
<tr class="separator:accb9db61d8aaceb0bcfac0c84b4f2cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14304b16a01b2b788f250e3698219c0"><td class="memItemLeft" align="right" valign="top"><a id="ab14304b16a01b2b788f250e3698219c0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#ab14304b16a01b2b788f250e3698219c0">count</a> (const <a class="el" href="classorbtree_1_1orbtree.html#a872823d333cf4224dedb47015117858e">key_type</a> &amp;k) const</td></tr>
<tr class="memdesc:ab14304b16a01b2b788f250e3698219c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">count number of elements with key <br /></td></tr>
<tr class="separator:ab14304b16a01b2b788f250e3698219c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17018a1f482b9aaffff617f2813e51b4"><td class="memTemplParams" colspan="2"><a id="a17018a1f482b9aaffff617f2813e51b4"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a17018a1f482b9aaffff617f2813e51b4"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a17018a1f482b9aaffff617f2813e51b4">count</a> (const K &amp;k) const</td></tr>
<tr class="memdesc:a17018a1f482b9aaffff617f2813e51b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">count the number of elements whose key compares equal to k <br /></td></tr>
<tr class="separator:a17018a1f482b9aaffff617f2813e51b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa72432f83b56e4b48e2104113586c48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#afa72432f83b56e4b48e2104113586c48">find</a> (const <a class="el" href="classorbtree_1_1orbtree.html#a872823d333cf4224dedb47015117858e">key_type</a> &amp;k)</td></tr>
<tr class="memdesc:afa72432f83b56e4b48e2104113586c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an element with the given key and return an iterator to it.  <a href="#afa72432f83b56e4b48e2104113586c48">More...</a><br /></td></tr>
<tr class="separator:afa72432f83b56e4b48e2104113586c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ff8f91ead2292f426e0e0f6c61994a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a18ff8f91ead2292f426e0e0f6c61994a">find</a> (const <a class="el" href="classorbtree_1_1orbtree.html#a872823d333cf4224dedb47015117858e">key_type</a> &amp;k) const</td></tr>
<tr class="memdesc:a18ff8f91ead2292f426e0e0f6c61994a"><td class="mdescLeft">&#160;</td><td class="mdescRight">iteraror that allows the modification of the stored value (for maps) <a class="el" href="classorbtree_1_1orbtree.html#afa72432f83b56e4b48e2104113586c48" title="Find an element with the given key and return an iterator to it. ">find(const key_type&amp; k)</a>  <a href="#a18ff8f91ead2292f426e0e0f6c61994a">More...</a><br /></td></tr>
<tr class="separator:a18ff8f91ead2292f426e0e0f6c61994a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e25c75f89126d0bd623f200dc09ad0"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:ac6e25c75f89126d0bd623f200dc09ad0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#ac6e25c75f89126d0bd623f200dc09ad0">find</a> (const K &amp;k)</td></tr>
<tr class="memdesc:ac6e25c75f89126d0bd623f200dc09ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">iteraror that allows the modification of the stored value (for maps) <a class="el" href="classorbtree_1_1orbtree.html#afa72432f83b56e4b48e2104113586c48" title="Find an element with the given key and return an iterator to it. ">find(const key_type&amp; k)</a>  <a href="#ac6e25c75f89126d0bd623f200dc09ad0">More...</a><br /></td></tr>
<tr class="separator:ac6e25c75f89126d0bd623f200dc09ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e517ba03db468a5e55069c223d57ee8"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:a6e517ba03db468a5e55069c223d57ee8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a6e517ba03db468a5e55069c223d57ee8">find</a> (const K &amp;k) const</td></tr>
<tr class="memdesc:a6e517ba03db468a5e55069c223d57ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">iteraror that allows the modification of the stored value (for maps) <a class="el" href="classorbtree_1_1orbtree.html#afa72432f83b56e4b48e2104113586c48" title="Find an element with the given key and return an iterator to it. ">find(const key_type&amp; k)</a>  <a href="#a6e517ba03db468a5e55069c223d57ee8">More...</a><br /></td></tr>
<tr class="separator:a6e517ba03db468a5e55069c223d57ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfb2e9dd0d53deb646a38dd1d9f76da"><td class="memItemLeft" align="right" valign="top"><a id="a8bfb2e9dd0d53deb646a38dd1d9f76da"></a>
<a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a8bfb2e9dd0d53deb646a38dd1d9f76da">lower_bound</a> (const <a class="el" href="classorbtree_1_1orbtree.html#a872823d333cf4224dedb47015117858e">key_type</a> &amp;k)</td></tr>
<tr class="memdesc:a8bfb2e9dd0d53deb646a38dd1d9f76da"><td class="mdescLeft">&#160;</td><td class="mdescRight">return an iterator to the first element with key not less than k <br /></td></tr>
<tr class="separator:a8bfb2e9dd0d53deb646a38dd1d9f76da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2bfdec121a742eb6f1bdac3a7fddef"><td class="memItemLeft" align="right" valign="top"><a id="a4b2bfdec121a742eb6f1bdac3a7fddef"></a>
<a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a4b2bfdec121a742eb6f1bdac3a7fddef">lower_bound</a> (const <a class="el" href="classorbtree_1_1orbtree.html#a872823d333cf4224dedb47015117858e">key_type</a> &amp;k) const</td></tr>
<tr class="memdesc:a4b2bfdec121a742eb6f1bdac3a7fddef"><td class="mdescLeft">&#160;</td><td class="mdescRight">return an iterator to the first element with key not less than k <br /></td></tr>
<tr class="separator:a4b2bfdec121a742eb6f1bdac3a7fddef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e59aa28176ad908e636ec4602bab5f"><td class="memTemplParams" colspan="2"><a id="a72e59aa28176ad908e636ec4602bab5f"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a72e59aa28176ad908e636ec4602bab5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a72e59aa28176ad908e636ec4602bab5f">lower_bound</a> (const K &amp;k)</td></tr>
<tr class="memdesc:a72e59aa28176ad908e636ec4602bab5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return an iterator to the first element with key not less than k <br /></td></tr>
<tr class="separator:a72e59aa28176ad908e636ec4602bab5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509f48bb7adfc924b6cb33590940eb00"><td class="memTemplParams" colspan="2"><a id="a509f48bb7adfc924b6cb33590940eb00"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a509f48bb7adfc924b6cb33590940eb00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a509f48bb7adfc924b6cb33590940eb00">lower_bound</a> (const K &amp;k) const</td></tr>
<tr class="memdesc:a509f48bb7adfc924b6cb33590940eb00"><td class="mdescLeft">&#160;</td><td class="mdescRight">return an iterator to the first element with key not less than k <br /></td></tr>
<tr class="separator:a509f48bb7adfc924b6cb33590940eb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4784ea629f4d659da78d37198a895be0"><td class="memItemLeft" align="right" valign="top"><a id="a4784ea629f4d659da78d37198a895be0"></a>
<a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a4784ea629f4d659da78d37198a895be0">upper_bound</a> (const <a class="el" href="classorbtree_1_1orbtree.html#a872823d333cf4224dedb47015117858e">key_type</a> &amp;k)</td></tr>
<tr class="memdesc:a4784ea629f4d659da78d37198a895be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return an iterator to the first element with key greater than k <br /></td></tr>
<tr class="separator:a4784ea629f4d659da78d37198a895be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3fad1e5ec0bfdeed47fd4fce344094"><td class="memItemLeft" align="right" valign="top"><a id="aaa3fad1e5ec0bfdeed47fd4fce344094"></a>
<a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#aaa3fad1e5ec0bfdeed47fd4fce344094">upper_bound</a> (const <a class="el" href="classorbtree_1_1orbtree.html#a872823d333cf4224dedb47015117858e">key_type</a> &amp;k) const</td></tr>
<tr class="memdesc:aaa3fad1e5ec0bfdeed47fd4fce344094"><td class="mdescLeft">&#160;</td><td class="mdescRight">return an iterator to the first element with key greater than k <br /></td></tr>
<tr class="separator:aaa3fad1e5ec0bfdeed47fd4fce344094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af165fd4a6133e619f01a0103e6f4fd8e"><td class="memTemplParams" colspan="2"><a id="af165fd4a6133e619f01a0103e6f4fd8e"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:af165fd4a6133e619f01a0103e6f4fd8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#af165fd4a6133e619f01a0103e6f4fd8e">upper_bound</a> (const K &amp;k)</td></tr>
<tr class="memdesc:af165fd4a6133e619f01a0103e6f4fd8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return an iterator to the first element with key greater than k <br /></td></tr>
<tr class="separator:af165fd4a6133e619f01a0103e6f4fd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e95539e1e76cd0b40ea05b672587fe2"><td class="memTemplParams" colspan="2"><a id="a6e95539e1e76cd0b40ea05b672587fe2"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a6e95539e1e76cd0b40ea05b672587fe2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a6e95539e1e76cd0b40ea05b672587fe2">upper_bound</a> (const K &amp;k) const</td></tr>
<tr class="memdesc:a6e95539e1e76cd0b40ea05b672587fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return an iterator to the first element with key greater than k <br /></td></tr>
<tr class="separator:a6e95539e1e76cd0b40ea05b672587fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe51c4eb15860a37f70828dff7d682d"><td class="memItemLeft" align="right" valign="top"><a id="a9fe51c4eb15860a37f70828dff7d682d"></a>
std::pair&lt; <a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a>, <a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a9fe51c4eb15860a37f70828dff7d682d">equal_range</a> (const <a class="el" href="classorbtree_1_1orbtree.html#a872823d333cf4224dedb47015117858e">key_type</a> &amp;k)</td></tr>
<tr class="memdesc:a9fe51c4eb15860a37f70828dff7d682d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a pair of iterators corresponding to the range of all elements with key equal to k <br /></td></tr>
<tr class="separator:a9fe51c4eb15860a37f70828dff7d682d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3142eb3092f3280bb55488284b90bbee"><td class="memItemLeft" align="right" valign="top"><a id="a3142eb3092f3280bb55488284b90bbee"></a>
std::pair&lt; <a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a>, <a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a3142eb3092f3280bb55488284b90bbee">equal_range</a> (const <a class="el" href="classorbtree_1_1orbtree.html#a872823d333cf4224dedb47015117858e">key_type</a> &amp;k) const</td></tr>
<tr class="memdesc:a3142eb3092f3280bb55488284b90bbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a pair of iterators corresponding to the range of all elements with key equal to k <br /></td></tr>
<tr class="separator:a3142eb3092f3280bb55488284b90bbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378fc05fb8d439f2fa880d567b3d93ab"><td class="memTemplParams" colspan="2"><a id="a378fc05fb8d439f2fa880d567b3d93ab"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a378fc05fb8d439f2fa880d567b3d93ab"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a>, <a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a378fc05fb8d439f2fa880d567b3d93ab">equal_range</a> (const K &amp;k)</td></tr>
<tr class="memdesc:a378fc05fb8d439f2fa880d567b3d93ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a pair of iterators corresponding to the range of all elements with keys that compares equal to k <br /></td></tr>
<tr class="separator:a378fc05fb8d439f2fa880d567b3d93ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c7f19bf7ecc2601e561053bfd659a0"><td class="memTemplParams" colspan="2"><a id="aa9c7f19bf7ecc2601e561053bfd659a0"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:aa9c7f19bf7ecc2601e561053bfd659a0"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a>, <a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#aa9c7f19bf7ecc2601e561053bfd659a0">equal_range</a> (const K &amp;k) const</td></tr>
<tr class="memdesc:aa9c7f19bf7ecc2601e561053bfd659a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a pair of iterators corresponding to the range of all elements with keys that compares equal to k <br /></td></tr>
<tr class="separator:aa9c7f19bf7ecc2601e561053bfd659a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bbcde385f71b09fd197c5e1fe6b4c7"><td class="memItemLeft" align="right" valign="top"><a id="a43bbcde385f71b09fd197c5e1fe6b4c7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a43bbcde385f71b09fd197c5e1fe6b4c7">contains</a> (const <a class="el" href="classorbtree_1_1orbtree.html#a872823d333cf4224dedb47015117858e">key_type</a> &amp;k) const</td></tr>
<tr class="memdesc:a43bbcde385f71b09fd197c5e1fe6b4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns if an element with key equivalent to k exists in this tree <br /></td></tr>
<tr class="separator:a43bbcde385f71b09fd197c5e1fe6b4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694c6d05835ebade07777f96e45963ae"><td class="memTemplParams" colspan="2"><a id="a694c6d05835ebade07777f96e45963ae"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a694c6d05835ebade07777f96e45963ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a694c6d05835ebade07777f96e45963ae">contains</a> (const K &amp;k) const</td></tr>
<tr class="memdesc:a694c6d05835ebade07777f96e45963ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns if an element with key equivalent to k exists in this tree <br /></td></tr>
<tr class="separator:a694c6d05835ebade07777f96e45963ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae182a2bbfc881111c60231aff335457b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#ae182a2bbfc881111c60231aff335457b">get_sum_node</a> (<a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a> it, <a class="el" href="classorbtree_1_1orbtree.html#a67c62695054716e369a4a9e370d5afb0">NVType</a> *res) const</td></tr>
<tr class="memdesc:ae182a2bbfc881111c60231aff335457b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate partial sum of the values stored in nodes that come before the one pointed to by it.  <a href="#ae182a2bbfc881111c60231aff335457b">More...</a><br /></td></tr>
<tr class="separator:ae182a2bbfc881111c60231aff335457b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa20acf7d4971e12efe16741ddda9f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#acaa20acf7d4971e12efe16741ddda9f1">get_sum</a> (const <a class="el" href="classorbtree_1_1orbtree.html#a872823d333cf4224dedb47015117858e">key_type</a> &amp;k, <a class="el" href="classorbtree_1_1orbtree.html#a67c62695054716e369a4a9e370d5afb0">NVType</a> *res) const</td></tr>
<tr class="memdesc:acaa20acf7d4971e12efe16741ddda9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate partial sum for keys that come before k.  <a href="#acaa20acf7d4971e12efe16741ddda9f1">More...</a><br /></td></tr>
<tr class="separator:acaa20acf7d4971e12efe16741ddda9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec3439e4356708dcf188eda51997c30"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:a5ec3439e4356708dcf188eda51997c30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree.html#a5ec3439e4356708dcf188eda51997c30">get_sum</a> (const K &amp;k, <a class="el" href="classorbtree_1_1orbtree.html#a67c62695054716e369a4a9e370d5afb0">NVType</a> *res) const</td></tr>
<tr class="memdesc:a5ec3439e4356708dcf188eda51997c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate partial sum for keys that come before k.  <a href="#a5ec3439e4356708dcf188eda51997c30">More...</a><br /></td></tr>
<tr class="separator:a5ec3439e4356708dcf188eda51997c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classorbtree_1_1orbtree__base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classorbtree_1_1orbtree__base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base&lt; NodeAllocator, Compare, NVFunc, multi &gt;</a></td></tr>
<tr class="memitem:abda5fbabf03eef9a04072d3bbef1201f inherit pub_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="abda5fbabf03eef9a04072d3bbef1201f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#abda5fbabf03eef9a04072d3bbef1201f">clear</a> ()</td></tr>
<tr class="memdesc:abda5fbabf03eef9a04072d3bbef1201f inherit pub_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase all nodes <br /></td></tr>
<tr class="separator:abda5fbabf03eef9a04072d3bbef1201f inherit pub_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95df4d552f3d7df3eac7cdb1f2d4ad14 inherit pub_methods_classorbtree_1_1orbtree__base"><td class="memTemplParams" colspan="2"><a id="a95df4d552f3d7df3eac7cdb1f2d4ad14"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a95df4d552f3d7df3eac7cdb1f2d4ad14 inherit pub_methods_classorbtree_1_1orbtree__base"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a95df4d552f3d7df3eac7cdb1f2d4ad14">get_sum_fv</a> (const K &amp;k, <a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a> *res) const</td></tr>
<tr class="memdesc:a95df4d552f3d7df3eac7cdb1f2d4ad14 inherit pub_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the generalized rank for a key, i.e. the sum of NVFunc for all nodes with node.key &lt; k <br /></td></tr>
<tr class="separator:a95df4d552f3d7df3eac7cdb1f2d4ad14 inherit pub_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fc2a50100d3c50fc10857628ea0051 inherit pub_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="ae2fc2a50100d3c50fc10857628ea0051"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ae2fc2a50100d3c50fc10857628ea0051">get_sum_fv_node</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> x, <a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a> *res) const</td></tr>
<tr class="memdesc:ae2fc2a50100d3c50fc10857628ea0051 inherit pub_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the generalized rank for a given node, i.e. the sum of NVFunv for all nodes before it in order <br /></td></tr>
<tr class="separator:ae2fc2a50100d3c50fc10857628ea0051 inherit pub_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfd4e40f0441cd5024f1006cfbb6b9d inherit pub_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a0bfd4e40f0441cd5024f1006cfbb6b9d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a0bfd4e40f0441cd5024f1006cfbb6b9d">get_norm_fv</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a> *res) const</td></tr>
<tr class="memdesc:a0bfd4e40f0441cd5024f1006cfbb6b9d inherit pub_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the normalization factor, i.e. the sum of all keys <br /></td></tr>
<tr class="separator:a0bfd4e40f0441cd5024f1006cfbb6b9d inherit pub_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05c1bb18a593ec67dbd8104f2c12b50 inherit pub_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ae05c1bb18a593ec67dbd8104f2c12b50">check_tree</a> (double epsilon=-1.0) const</td></tr>
<tr class="memdesc:ae05c1bb18a593ec67dbd8104f2c12b50 inherit pub_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">check that the tree is valid  <a href="classorbtree_1_1orbtree__base.html#ae05c1bb18a593ec67dbd8104f2c12b50">More...</a><br /></td></tr>
<tr class="separator:ae05c1bb18a593ec67dbd8104f2c12b50 inherit pub_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a882123f478b791f197264cf0be6859 inherit pub_methods_classorbtree_1_1orbtree__base"><td class="memTemplParams" colspan="2"><a id="a7a882123f478b791f197264cf0be6859"></a>
template&lt;class... T&gt; </td></tr>
<tr class="memitem:a7a882123f478b791f197264cf0be6859 inherit pub_methods_classorbtree_1_1orbtree__base"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace</b> (T &amp;&amp;... t) -&gt; std::pair&lt; <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>, bool &gt;</td></tr>
<tr class="separator:a7a882123f478b791f197264cf0be6859 inherit pub_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119752977bd6abaf3b662df85b22255c inherit pub_methods_classorbtree_1_1orbtree__base"><td class="memTemplParams" colspan="2"><a id="a119752977bd6abaf3b662df85b22255c"></a>
template&lt;class... T&gt; </td></tr>
<tr class="memitem:a119752977bd6abaf3b662df85b22255c inherit pub_methods_classorbtree_1_1orbtree__base"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_hint</b> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> hint, T &amp;&amp;... t) -&gt; <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a></td></tr>
<tr class="separator:a119752977bd6abaf3b662df85b22255c inherit pub_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a66be00a98027444bfbf8b25a78376712"><td class="memItemLeft" align="right" valign="top"><a id="a66be00a98027444bfbf8b25a78376712"></a>
typedef <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree_base</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::NodeHandle&#160;</td><td class="memItemRight" valign="bottom"><b>NodeHandle</b></td></tr>
<tr class="separator:a66be00a98027444bfbf8b25a78376712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f833e56f25b359e8e2e07e7519efdc"><td class="memItemLeft" align="right" valign="top"><a id="ab6f833e56f25b359e8e2e07e7519efdc"></a>
typedef <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree_base</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::KeyValue&#160;</td><td class="memItemRight" valign="bottom"><b>KeyValue</b></td></tr>
<tr class="separator:ab6f833e56f25b359e8e2e07e7519efdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classorbtree_1_1orbtree__base"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classorbtree_1_1orbtree__base')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base&lt; NodeAllocator, Compare, NVFunc, multi &gt;</a></td></tr>
<tr class="memitem:a5912e87855b088de32ea2be5030bd848 inherit pro_types_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a5912e87855b088de32ea2be5030bd848"></a>
typedef NodeAllocator::Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a></td></tr>
<tr class="memdesc:a5912e87855b088de32ea2be5030bd848 inherit pro_types_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">node objects <br /></td></tr>
<tr class="separator:a5912e87855b088de32ea2be5030bd848 inherit pro_types_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2517a6321b0effc53eb6a1fad87642 inherit pro_types_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a8c2517a6321b0effc53eb6a1fad87642"></a>
typedef NodeAllocator::KeyValue&#160;</td><td class="memItemRight" valign="bottom"><b>KeyValue</b></td></tr>
<tr class="separator:a8c2517a6321b0effc53eb6a1fad87642 inherit pro_types_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f7b4d38a621ca5749f5ff9ed55d12d inherit pro_types_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a67f7b4d38a621ca5749f5ff9ed55d12d"></a>
typedef NodeAllocator::KeyValue::KeyType&#160;</td><td class="memItemRight" valign="bottom"><b>KeyType</b></td></tr>
<tr class="separator:a67f7b4d38a621ca5749f5ff9ed55d12d inherit pro_types_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ba1b334a2d33d146b3e62d6b89c0a1 inherit pro_types_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a65ba1b334a2d33d146b3e62d6b89c0a1"></a>
typedef NodeAllocator::KeyValue::ValueType&#160;</td><td class="memItemRight" valign="bottom"><b>ValueType</b></td></tr>
<tr class="separator:a65ba1b334a2d33d146b3e62d6b89c0a1 inherit pro_types_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652905b3ff5eb2166f427aa7f558d498 inherit pro_types_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a652905b3ff5eb2166f427aa7f558d498"></a>
typedef NodeAllocator::NodeHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a></td></tr>
<tr class="memdesc:a652905b3ff5eb2166f427aa7f558d498 inherit pro_types_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle to refer nodes to (pointer or integer) <br /></td></tr>
<tr class="separator:a652905b3ff5eb2166f427aa7f558d498 inherit pro_types_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8eb417edd55f091b7f5469dcff1685fe"><td class="memTemplParams" colspan="2"><a id="a8eb417edd55f091b7f5469dcff1685fe"></a>
template&lt;bool multi_ = multi&gt; </td></tr>
<tr class="memitem:a8eb417edd55f091b7f5469dcff1685fe"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; multi_, <a class="el" href="classorbtree_1_1orbtree.html#a552618d05b82e96fe8914eb484ebed09">insert_type</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_helper</b> (const <a class="el" href="classorbtree_1_1orbtree.html#a881f04f49d41692ff98d8bda444f9a43">value_type</a> &amp;v)</td></tr>
<tr class="separator:a8eb417edd55f091b7f5469dcff1685fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f0471e56ad0f251d21ce630ad525ce"><td class="memTemplParams" colspan="2"><a id="a43f0471e56ad0f251d21ce630ad525ce"></a>
template&lt;bool multi_ = multi&gt; </td></tr>
<tr class="memitem:a43f0471e56ad0f251d21ce630ad525ce"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!multi_, <a class="el" href="classorbtree_1_1orbtree.html#a552618d05b82e96fe8914eb484ebed09">insert_type</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_helper</b> (const <a class="el" href="classorbtree_1_1orbtree.html#a881f04f49d41692ff98d8bda444f9a43">value_type</a> &amp;v)</td></tr>
<tr class="separator:a43f0471e56ad0f251d21ce630ad525ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012132b3afe409aaa58636b710e1da58"><td class="memTemplParams" colspan="2"><a id="a012132b3afe409aaa58636b710e1da58"></a>
template&lt;bool multi_ = multi&gt; </td></tr>
<tr class="memitem:a012132b3afe409aaa58636b710e1da58"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; multi_, <a class="el" href="classorbtree_1_1orbtree.html#a552618d05b82e96fe8914eb484ebed09">insert_type</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_helper</b> (<a class="el" href="classorbtree_1_1orbtree.html#a881f04f49d41692ff98d8bda444f9a43">value_type</a> &amp;&amp;v)</td></tr>
<tr class="separator:a012132b3afe409aaa58636b710e1da58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51f3c5327298f9e633c65c40a331327"><td class="memTemplParams" colspan="2"><a id="ad51f3c5327298f9e633c65c40a331327"></a>
template&lt;bool multi_ = multi&gt; </td></tr>
<tr class="memitem:ad51f3c5327298f9e633c65c40a331327"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!multi_, <a class="el" href="classorbtree_1_1orbtree.html#a552618d05b82e96fe8914eb484ebed09">insert_type</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_helper</b> (<a class="el" href="classorbtree_1_1orbtree.html#a881f04f49d41692ff98d8bda444f9a43">value_type</a> &amp;&amp;v)</td></tr>
<tr class="separator:ad51f3c5327298f9e633c65c40a331327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f49d195a77dca11fdb05a3432332b6"><td class="memTemplParams" colspan="2"><a id="ad6f49d195a77dca11fdb05a3432332b6"></a>
template&lt;class... Args, bool multi_ = multi&gt; </td></tr>
<tr class="memitem:ad6f49d195a77dca11fdb05a3432332b6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; multi_, <a class="el" href="classorbtree_1_1orbtree.html#a552618d05b82e96fe8914eb484ebed09">insert_type</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_helper</b> (Args &amp;... args)</td></tr>
<tr class="separator:ad6f49d195a77dca11fdb05a3432332b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2ec1bd1ccddd1a0bfbca425c0d0c3a"><td class="memTemplParams" colspan="2"><a id="a5a2ec1bd1ccddd1a0bfbca425c0d0c3a"></a>
template&lt;class... Args, bool multi_ = multi&gt; </td></tr>
<tr class="memitem:a5a2ec1bd1ccddd1a0bfbca425c0d0c3a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!multi_, <a class="el" href="classorbtree_1_1orbtree.html#a552618d05b82e96fe8914eb484ebed09">insert_type</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_helper</b> (Args &amp;... args)</td></tr>
<tr class="separator:a5a2ec1bd1ccddd1a0bfbca425c0d0c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classorbtree_1_1orbtree__base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classorbtree_1_1orbtree__base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base&lt; NodeAllocator, Compare, NVFunc, multi &gt;</a></td></tr>
<tr class="memitem:a2f11984af283322c6b4499bca5ae92ab inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a2f11984af283322c6b4499bca5ae92ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a2f11984af283322c6b4499bca5ae92ab">NVAdd</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a> *x, const <a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a> *y) const</td></tr>
<tr class="memdesc:a2f11984af283322c6b4499bca5ae92ab inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to add NVType values; checks for overflow and throws exception in the case of integral types <br /></td></tr>
<tr class="separator:a2f11984af283322c6b4499bca5ae92ab inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac02719774296a202210b3f2ebbf8c18 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="aac02719774296a202210b3f2ebbf8c18"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#aac02719774296a202210b3f2ebbf8c18">NVSubtract</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a> *x, const <a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a> *y) const</td></tr>
<tr class="memdesc:aac02719774296a202210b3f2ebbf8c18 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to subtract NVType values; checks for overflow and throws exception in the case of integral types <br /></td></tr>
<tr class="separator:aac02719774296a202210b3f2ebbf8c18 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f409bc49cd728e3a26a0a31eae73524 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a8f409bc49cd728e3a26a0a31eae73524"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>create_sentinels</b> ()</td></tr>
<tr class="separator:a8f409bc49cd728e3a26a0a31eae73524 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340e5dba4f706fb00237c3273db222f2 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a340e5dba4f706fb00237c3273db222f2"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a340e5dba4f706fb00237c3273db222f2">get_node</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n)</td></tr>
<tr class="memdesc:a340e5dba4f706fb00237c3273db222f2 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function that returns node object for a node handle <br /></td></tr>
<tr class="separator:a340e5dba4f706fb00237c3273db222f2 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a04bf4f4cbd380f55bd67217f78143 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="aa8a04bf4f4cbd380f55bd67217f78143"></a>
const <a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#aa8a04bf4f4cbd380f55bd67217f78143">get_node</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:aa8a04bf4f4cbd380f55bd67217f78143 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function that returns node object for a node handle <br /></td></tr>
<tr class="separator:aa8a04bf4f4cbd380f55bd67217f78143 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1ce6c48fab1be08446ecf367af59e1 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a7d1ce6c48fab1be08446ecf367af59e1"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a7d1ce6c48fab1be08446ecf367af59e1">root</a> () const</td></tr>
<tr class="memdesc:a7d1ce6c48fab1be08446ecf367af59e1 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle of root sentinel <br /></td></tr>
<tr class="separator:a7d1ce6c48fab1be08446ecf367af59e1 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10de0a6bb5dbdcadf06f821a8cdd17c3 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a10de0a6bb5dbdcadf06f821a8cdd17c3"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a10de0a6bb5dbdcadf06f821a8cdd17c3">nil</a> () const</td></tr>
<tr class="memdesc:a10de0a6bb5dbdcadf06f821a8cdd17c3 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle of nil sentinel <br /></td></tr>
<tr class="separator:a10de0a6bb5dbdcadf06f821a8cdd17c3 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38005be543419c33fc8087dcbc6ca0e4 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a38005be543419c33fc8087dcbc6ca0e4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>orbtree_base</b> (const NVFunc &amp;f_, const Compare &amp;c_)</td></tr>
<tr class="separator:a38005be543419c33fc8087dcbc6ca0e4 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958aa7faf3a6f99967d01d51c4dde35b inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a958aa7faf3a6f99967d01d51c4dde35b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>orbtree_base</b> (NVFunc &amp;&amp;f_, const Compare &amp;c_)</td></tr>
<tr class="separator:a958aa7faf3a6f99967d01d51c4dde35b inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dc66c1458508a0e07ca807d892bd8d inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#af0dc66c1458508a0e07ca807d892bd8d">insert</a> (ValueType &amp;&amp;kv)</td></tr>
<tr class="memdesc:af0dc66c1458508a0e07ca807d892bd8d inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new element.  <a href="classorbtree_1_1orbtree__base.html#af0dc66c1458508a0e07ca807d892bd8d">More...</a><br /></td></tr>
<tr class="separator:af0dc66c1458508a0e07ca807d892bd8d inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df163156f3b051f64d1d7f6a8c5fa49 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a6df163156f3b051f64d1d7f6a8c5fa49">insert</a> (const ValueType &amp;kv)</td></tr>
<tr class="memdesc:a6df163156f3b051f64d1d7f6a8c5fa49 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new element.  <a href="classorbtree_1_1orbtree__base.html#a6df163156f3b051f64d1d7f6a8c5fa49">More...</a><br /></td></tr>
<tr class="separator:a6df163156f3b051f64d1d7f6a8c5fa49 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039050dc8bfea58a1f2be1562d2bcfe5 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a039050dc8bfea58a1f2be1562d2bcfe5">insert</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> hint, ValueType &amp;&amp;kv)</td></tr>
<tr class="memdesc:a039050dc8bfea58a1f2be1562d2bcfe5 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new element with hint.  <a href="classorbtree_1_1orbtree__base.html#a039050dc8bfea58a1f2be1562d2bcfe5">More...</a><br /></td></tr>
<tr class="separator:a039050dc8bfea58a1f2be1562d2bcfe5 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d07029a57c517922f7290fddcc866df inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a4d07029a57c517922f7290fddcc866df">insert</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> hint, const ValueType &amp;kv)</td></tr>
<tr class="memdesc:a4d07029a57c517922f7290fddcc866df inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new element with hint.  <a href="classorbtree_1_1orbtree__base.html#a4d07029a57c517922f7290fddcc866df">More...</a><br /></td></tr>
<tr class="separator:a4d07029a57c517922f7290fddcc866df inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3237f082391ba490c1c3604e932d5417 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:a3237f082391ba490c1c3604e932d5417 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a3237f082391ba490c1c3604e932d5417">emplace</a> (T &amp;&amp;... t)</td></tr>
<tr class="memdesc:a3237f082391ba490c1c3604e932d5417 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct new element in place.  <a href="classorbtree_1_1orbtree__base.html#a3237f082391ba490c1c3604e932d5417">More...</a><br /></td></tr>
<tr class="separator:a3237f082391ba490c1c3604e932d5417 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200289ad5fdc385987b6325495fe988f inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:a200289ad5fdc385987b6325495fe988f inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a200289ad5fdc385987b6325495fe988f">emplace_hint</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> hint, T &amp;&amp;... t)</td></tr>
<tr class="memdesc:a200289ad5fdc385987b6325495fe988f inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct new element in place with hint.  <a href="classorbtree_1_1orbtree__base.html#a200289ad5fdc385987b6325495fe988f">More...</a><br /></td></tr>
<tr class="separator:a200289ad5fdc385987b6325495fe988f inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd31623c93494bd95ff14867329fff6 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a3bd31623c93494bd95ff14867329fff6">insert_search</a> (const KeyType &amp;k, <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> &amp;n, bool &amp;insert_left) const</td></tr>
<tr class="memdesc:a3bd31623c93494bd95ff14867329fff6 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper for insert &ndash; find the location where to insert  <a href="classorbtree_1_1orbtree__base.html#a3bd31623c93494bd95ff14867329fff6">More...</a><br /></td></tr>
<tr class="separator:a3bd31623c93494bd95ff14867329fff6 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6358fbacede2dab1e0783b9b78e400e8 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a6358fbacede2dab1e0783b9b78e400e8">insert_search_hint</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> hint, const KeyType &amp;k, <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> &amp;n, bool &amp;insert_left) const</td></tr>
<tr class="memdesc:a6358fbacede2dab1e0783b9b78e400e8 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper for insert &ndash; find the location where to insert  <a href="classorbtree_1_1orbtree__base.html#a6358fbacede2dab1e0783b9b78e400e8">More...</a><br /></td></tr>
<tr class="separator:a6358fbacede2dab1e0783b9b78e400e8 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52ddab1f32195085b53311712f21f76 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ac52ddab1f32195085b53311712f21f76">insert_helper</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n, <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n1, bool insert_left)</td></tr>
<tr class="memdesc:ac52ddab1f32195085b53311712f21f76 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to do the real work for insert  <a href="classorbtree_1_1orbtree__base.html#ac52ddab1f32195085b53311712f21f76">More...</a><br /></td></tr>
<tr class="separator:ac52ddab1f32195085b53311712f21f76 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66b464b7b745a1f402e17842a037083 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:ae66b464b7b745a1f402e17842a037083 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ae66b464b7b745a1f402e17842a037083">find</a> (const K &amp;key) const -&gt; <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a></td></tr>
<tr class="memdesc:ae66b464b7b745a1f402e17842a037083 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">find any node with the given key  <a href="classorbtree_1_1orbtree__base.html#ae66b464b7b745a1f402e17842a037083">More...</a><br /></td></tr>
<tr class="separator:ae66b464b7b745a1f402e17842a037083 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94afd66e7745a0773237ded2135a9a0 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memTemplParams" colspan="2"><a id="ad94afd66e7745a0773237ded2135a9a0"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:ad94afd66e7745a0773237ded2135a9a0 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ad94afd66e7745a0773237ded2135a9a0">lower_bound</a> (const K &amp;key) const -&gt; <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a></td></tr>
<tr class="memdesc:ad94afd66e7745a0773237ded2135a9a0 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first node not less than the given key &ndash; returns nil if none found <br /></td></tr>
<tr class="separator:ad94afd66e7745a0773237ded2135a9a0 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960028ee70919aeac975881a0111875a inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memTemplParams" colspan="2"><a id="a960028ee70919aeac975881a0111875a"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a960028ee70919aeac975881a0111875a inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a960028ee70919aeac975881a0111875a">upper_bound</a> (const K &amp;key) const -&gt; <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a></td></tr>
<tr class="memdesc:a960028ee70919aeac975881a0111875a inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first node larger than the given key &ndash; returns nil if none found <br /></td></tr>
<tr class="separator:a960028ee70919aeac975881a0111875a inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1581d4499f2bc74428671cb94530e7cb inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a1581d4499f2bc74428671cb94530e7cb"></a>
const KeyType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a1581d4499f2bc74428671cb94530e7cb">get_node_key</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:a1581d4499f2bc74428671cb94530e7cb inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function to get the key of a node <br /></td></tr>
<tr class="separator:a1581d4499f2bc74428671cb94530e7cb inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05eae072c643a66f8edf4d0d8479a4a4 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a05eae072c643a66f8edf4d0d8479a4a4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a05eae072c643a66f8edf4d0d8479a4a4">compare_key_equals</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n, const KeyType &amp;k) const</td></tr>
<tr class="memdesc:a05eae072c643a66f8edf4d0d8479a4a4 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper for erase to compare elements <br /></td></tr>
<tr class="separator:a05eae072c643a66f8edf4d0d8479a4a4 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb66c8e1850f5683fc6dc5dbd29dec1b inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#abb66c8e1850f5683fc6dc5dbd29dec1b">get_node_grvalue</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n, <a class="el" href="classorbtree_1_1orbtree__base.html#ad94ad812f92bd1f2f156d6140a2833a0">NVType</a> *res) const</td></tr>
<tr class="memdesc:abb66c8e1850f5683fc6dc5dbd29dec1b inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the value of NVFunc for the given node  <a href="classorbtree_1_1orbtree__base.html#abb66c8e1850f5683fc6dc5dbd29dec1b">More...</a><br /></td></tr>
<tr class="separator:abb66c8e1850f5683fc6dc5dbd29dec1b inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c92f44eef353e6feea10b24647a6850 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a0c92f44eef353e6feea10b24647a6850"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a0c92f44eef353e6feea10b24647a6850">first</a> () const</td></tr>
<tr class="memdesc:a0c92f44eef353e6feea10b24647a6850 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">get first node (or nil) <br /></td></tr>
<tr class="separator:a0c92f44eef353e6feea10b24647a6850 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5478426317ce688d2c1a3ecf33efdc7a inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a5478426317ce688d2c1a3ecf33efdc7a"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a5478426317ce688d2c1a3ecf33efdc7a">last</a> () const</td></tr>
<tr class="memdesc:a5478426317ce688d2c1a3ecf33efdc7a inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">get last node (or nil) <br /></td></tr>
<tr class="separator:a5478426317ce688d2c1a3ecf33efdc7a inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e914d88fe2d60947318a036412cb69 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="ae2e914d88fe2d60947318a036412cb69"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ae2e914d88fe2d60947318a036412cb69">next</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:ae2e914d88fe2d60947318a036412cb69 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">get node after n (or nil) &ndash; note: next(nil) == nil <br /></td></tr>
<tr class="separator:ae2e914d88fe2d60947318a036412cb69 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90917516903a7116aae29025f91f59c0 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a90917516903a7116aae29025f91f59c0"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a90917516903a7116aae29025f91f59c0">previous</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:a90917516903a7116aae29025f91f59c0 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">get node before n (or nil) &ndash; note: previous(nil) == <a class="el" href="classorbtree_1_1orbtree__base.html#a5478426317ce688d2c1a3ecf33efdc7a" title="get last node (or nil) ">last()</a> to make it easier to implement end() iterator <br /></td></tr>
<tr class="separator:a90917516903a7116aae29025f91f59c0 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7c194e2e1227886e2c8273f6531f59 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a0b7c194e2e1227886e2c8273f6531f59"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a0b7c194e2e1227886e2c8273f6531f59">erase</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n)</td></tr>
<tr class="memdesc:a0b7c194e2e1227886e2c8273f6531f59 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the given node &ndash; return the next node (i.e. next(n) before deleting n) <br /></td></tr>
<tr class="separator:a0b7c194e2e1227886e2c8273f6531f59 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c60ee1b54d9615d995dab6256056984 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a3c60ee1b54d9615d995dab6256056984"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a3c60ee1b54d9615d995dab6256056984">get_left</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n)</td></tr>
<tr class="memdesc:a3c60ee1b54d9615d995dab6256056984 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience helper to get node object that is the left child of the given node handle <br /></td></tr>
<tr class="separator:a3c60ee1b54d9615d995dab6256056984 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05677939b594328aa1c49c2d6af9529 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="ab05677939b594328aa1c49c2d6af9529"></a>
const <a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ab05677939b594328aa1c49c2d6af9529">get_left</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:ab05677939b594328aa1c49c2d6af9529 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience helper to get node object that is the left child of the given node handle <br /></td></tr>
<tr class="separator:ab05677939b594328aa1c49c2d6af9529 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a05d777bc25159b8cbc2eb8b6f9b07e inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a3a05d777bc25159b8cbc2eb8b6f9b07e"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a3a05d777bc25159b8cbc2eb8b6f9b07e">get_right</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n)</td></tr>
<tr class="memdesc:a3a05d777bc25159b8cbc2eb8b6f9b07e inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience helper to get node object that is the right child of the given node handle <br /></td></tr>
<tr class="separator:a3a05d777bc25159b8cbc2eb8b6f9b07e inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edf15f1c988a532563ee5a327ac1384 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a7edf15f1c988a532563ee5a327ac1384"></a>
const <a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a7edf15f1c988a532563ee5a327ac1384">get_right</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:a7edf15f1c988a532563ee5a327ac1384 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience helper to get node object that is the right child of the given node handle <br /></td></tr>
<tr class="separator:a7edf15f1c988a532563ee5a327ac1384 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c8f9ff96f4e4f139ddb65c2dae6ec8 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="ac7c8f9ff96f4e4f139ddb65c2dae6ec8"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ac7c8f9ff96f4e4f139ddb65c2dae6ec8">get_parent</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n)</td></tr>
<tr class="memdesc:ac7c8f9ff96f4e4f139ddb65c2dae6ec8 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience helper to get node object that is the parent of the given node handle <br /></td></tr>
<tr class="separator:ac7c8f9ff96f4e4f139ddb65c2dae6ec8 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9640bfd4f7b326c79f1dd2d99faf4144 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a9640bfd4f7b326c79f1dd2d99faf4144"></a>
const <a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a9640bfd4f7b326c79f1dd2d99faf4144">get_parent</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:a9640bfd4f7b326c79f1dd2d99faf4144 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience helper to get node object that is the parent of the given node handle <br /></td></tr>
<tr class="separator:a9640bfd4f7b326c79f1dd2d99faf4144 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b55bbeead05fb1de7d7da23933d333 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="ad7b55bbeead05fb1de7d7da23933d333"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#ad7b55bbeead05fb1de7d7da23933d333">get_sibling_handle</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:ad7b55bbeead05fb1de7d7da23933d333 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience helper to get the handle of a node's sibling (i.e. parent's other child) <br /></td></tr>
<tr class="separator:ad7b55bbeead05fb1de7d7da23933d333 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5754e3fabc8a6bb299b53d33f71cba20 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a5754e3fabc8a6bb299b53d33f71cba20"></a>
<a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a5754e3fabc8a6bb299b53d33f71cba20">get_sibling</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n)</td></tr>
<tr class="memdesc:a5754e3fabc8a6bb299b53d33f71cba20 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience helper to get the node object of a node's sibling (i.e. parent's other child) <br /></td></tr>
<tr class="separator:a5754e3fabc8a6bb299b53d33f71cba20 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12fc3eb265da99f98b5b76702322b46 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="aa12fc3eb265da99f98b5b76702322b46"></a>
const <a class="el" href="classorbtree_1_1orbtree__base.html#a5912e87855b088de32ea2be5030bd848">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#aa12fc3eb265da99f98b5b76702322b46">get_sibling</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:aa12fc3eb265da99f98b5b76702322b46 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience helper to get the node object of a node's sibling (i.e. parent's other child) <br /></td></tr>
<tr class="separator:aa12fc3eb265da99f98b5b76702322b46 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fa240f80095af695eed678e84a9641 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a52fa240f80095af695eed678e84a9641"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a52fa240f80095af695eed678e84a9641">is_left_side</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n) const</td></tr>
<tr class="memdesc:a52fa240f80095af695eed678e84a9641 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">check which side child is n (i.e. returns true if n is the left child of its parent) &ndash; requires that n != root <br /></td></tr>
<tr class="separator:a52fa240f80095af695eed678e84a9641 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c213e1b016ba48d64a983dcad5ad315 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a1c213e1b016ba48d64a983dcad5ad315"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a1c213e1b016ba48d64a983dcad5ad315">update_sum</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n)</td></tr>
<tr class="memdesc:a1c213e1b016ba48d64a983dcad5ad315 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the sum only inside n <br /></td></tr>
<tr class="separator:a1c213e1b016ba48d64a983dcad5ad315 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9214c4eb5277b64e7c7fd4cbbfc0844 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="af9214c4eb5277b64e7c7fd4cbbfc0844"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#af9214c4eb5277b64e7c7fd4cbbfc0844">update_sum_r</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n)</td></tr>
<tr class="memdesc:af9214c4eb5277b64e7c7fd4cbbfc0844 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the sum recursively up the tree <br /></td></tr>
<tr class="separator:af9214c4eb5277b64e7c7fd4cbbfc0844 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efef5dfbb0163f75b27c7a43275950e inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memTemplParams" colspan="2"><a id="a9efef5dfbb0163f75b27c7a43275950e"></a>
template&lt;class KeyValue_  = KeyValue&gt; </td></tr>
<tr class="memitem:a9efef5dfbb0163f75b27c7a43275950e inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a9efef5dfbb0163f75b27c7a43275950e">update_value</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n, typename KeyValue_::MappedType const &amp;v)</td></tr>
<tr class="memdesc:a9efef5dfbb0163f75b27c7a43275950e inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">update value in a node &ndash; only if this is a map; update sum recursively based on it as well <br /></td></tr>
<tr class="separator:a9efef5dfbb0163f75b27c7a43275950e inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e20acaf610c7bacc3b6dc44512826a inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memTemplParams" colspan="2"><a id="a37e20acaf610c7bacc3b6dc44512826a"></a>
template&lt;class KeyValue_  = KeyValue&gt; </td></tr>
<tr class="memitem:a37e20acaf610c7bacc3b6dc44512826a inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a37e20acaf610c7bacc3b6dc44512826a">update_value</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> n, typename KeyValue_::MappedType &amp;&amp;v)</td></tr>
<tr class="memdesc:a37e20acaf610c7bacc3b6dc44512826a inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">update value in a node &ndash; only if this is a map; update sum recursively based on it as well <br /></td></tr>
<tr class="separator:a37e20acaf610c7bacc3b6dc44512826a inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68eeccfe36447a54c3344fc79187b533 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a68eeccfe36447a54c3344fc79187b533">rotate_left</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> x)</td></tr>
<tr class="memdesc:a68eeccfe36447a54c3344fc79187b533 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">left rotate  <a href="classorbtree_1_1orbtree__base.html#a68eeccfe36447a54c3344fc79187b533">More...</a><br /></td></tr>
<tr class="separator:a68eeccfe36447a54c3344fc79187b533 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537ce2b7bf2baeeef5dfb534a47a9f96 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a537ce2b7bf2baeeef5dfb534a47a9f96">rotate_right</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> x)</td></tr>
<tr class="memdesc:a537ce2b7bf2baeeef5dfb534a47a9f96 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">right rotate  <a href="classorbtree_1_1orbtree__base.html#a537ce2b7bf2baeeef5dfb534a47a9f96">More...</a><br /></td></tr>
<tr class="separator:a537ce2b7bf2baeeef5dfb534a47a9f96 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a7f731d8ee936c2d140bc7f0c3b734 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a82a7f731d8ee936c2d140bc7f0c3b734"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a82a7f731d8ee936c2d140bc7f0c3b734">rotate_parent</a> (<a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> x)</td></tr>
<tr class="memdesc:a82a7f731d8ee936c2d140bc7f0c3b734 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotate by parent of x (x takes parent's place), this calls either <a class="el" href="classorbtree_1_1orbtree__base.html#a68eeccfe36447a54c3344fc79187b533" title="left rotate ">rotate_left()</a> or <a class="el" href="classorbtree_1_1orbtree__base.html#a537ce2b7bf2baeeef5dfb534a47a9f96" title="right rotate ">rotate_right()</a> with the parent of x <br /></td></tr>
<tr class="separator:a82a7f731d8ee936c2d140bc7f0c3b734 inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95a96c37ba6e241eada4e623748200f inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="af95a96c37ba6e241eada4e623748200f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#af95a96c37ba6e241eada4e623748200f">check_tree_r</a> (double epsilon, <a class="el" href="classorbtree_1_1orbtree__base.html#a652905b3ff5eb2166f427aa7f558d498">NodeHandle</a> x, size_t black_count, size_t &amp;previous_black_count) const</td></tr>
<tr class="memdesc:af95a96c37ba6e241eada4e623748200f inherit pro_methods_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursive helper for check_tree(double) <br /></td></tr>
<tr class="separator:af95a96c37ba6e241eada4e623748200f inherit pro_methods_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classorbtree_1_1orbtree__base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classorbtree_1_1orbtree__base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classorbtree_1_1orbtree__base.html">orbtree::orbtree_base&lt; NodeAllocator, Compare, NVFunc, multi &gt;</a></td></tr>
<tr class="memitem:a65ffeb74cf7633cd43f16274c9522757 inherit pro_attribs_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a65ffeb74cf7633cd43f16274c9522757"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorbtree_1_1orbtree__base.html#a65ffeb74cf7633cd43f16274c9522757">size1</a></td></tr>
<tr class="memdesc:a65ffeb74cf7633cd43f16274c9522757 inherit pro_attribs_classorbtree_1_1orbtree__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">keep track of the number of inserted elements <br /></td></tr>
<tr class="separator:a65ffeb74cf7633cd43f16274c9522757 inherit pro_attribs_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9ac29180f46526d3139913425540e1 inherit pro_attribs_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="a4b9ac29180f46526d3139913425540e1"></a>
NVFunc&#160;</td><td class="memItemRight" valign="bottom"><b>f</b></td></tr>
<tr class="separator:a4b9ac29180f46526d3139913425540e1 inherit pro_attribs_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbed14df189c55d6ea4551cb1ea417ef inherit pro_attribs_classorbtree_1_1orbtree__base"><td class="memItemLeft" align="right" valign="top"><a id="adbed14df189c55d6ea4551cb1ea417ef"></a>
Compare&#160;</td><td class="memItemRight" valign="bottom"><b>c</b></td></tr>
<tr class="separator:adbed14df189c55d6ea4551cb1ea417ef inherit pro_attribs_classorbtree_1_1orbtree__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class NodeAllocator, class Compare, class NVFunc, bool multi&gt;<br />
class orbtree::orbtree&lt; NodeAllocator, Compare, NVFunc, multi &gt;</h3>

<p>Generalized order statistic tree main interface. It is recommended to use the templates <a class="el" href="classorbtree_1_1orbset.html">orbset</a>, <a class="el" href="classorbtree_1_1orbsetC.html" title="Specialized set with compact storage, for POD (trivially copyable) elements. See orbtree::orbtree for...">orbsetC</a>, <a class="el" href="classorbtree_1_1orbmultiset.html">orbmultiset</a>, <a class="el" href="classorbtree_1_1orbmultisetC.html" title="Specialized multiset with compact storage, for POD (trivially copyable) elements. See orbtree::orbtre...">orbmultisetC</a>, <a class="el" href="classorbtree_1_1orbmap.html">orbmap</a>, <a class="el" href="classorbtree_1_1orbmapC.html" title="Map implementation with compact storage. See orbtree and orbtreemap for description of members...">orbmapC</a>, <a class="el" href="classorbtree_1_1orbmultimap.html">orbmultimap</a> and <a class="el" href="classorbtree_1_1orbmultimapC.html" title="Multimap implementation with compact storage. See orbtree for description of members. Key and value must be POD-types. ">orbmultimapC</a> to instantiate various versions instead of directly using this class template. </p>
<p>Generalized order statistic tree main interface. This class provides common functionality for sets, maps, multisets and multimaps, depending on the templates provided. Most of the interface is defined here. Interface should be as similar as possible to std::set, std::multiset, std::map and std::multimap.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NodeAllocator</td><td>internal base class to store nodes </td></tr>
    <tr><td class="paramname">Comapre</td><td>comparison functor </td></tr>
    <tr><td class="paramname">NVFunc</td><td>function that calculates values associated with elements based on key and value </td></tr>
    <tr><td class="paramname">multi</td><td>determines if this is a multiset / multimap (keys can be present multiple times) or not </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="afa72432f83b56e4b48e2104113586c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa72432f83b56e4b48e2104113586c48">&#9670;&nbsp;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator, class Compare, class NVFunc, bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a> <a class="el" href="classorbtree_1_1orbtree.html">orbtree::orbtree</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classorbtree_1_1orbtree.html#a872823d333cf4224dedb47015117858e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an element with the given key and return an iterator to it. </p>
<p>Returns the past-the-end iterator if no such element is found.</p>
<p>In case of multimap / multiset, any element with such key can be returned. Use <a class="el" href="classorbtree_1_1orbtree.html#a8bfb2e9dd0d53deb646a38dd1d9f76da" title="return an iterator to the first element with key not less than k ">lower_bound()</a> and <a class="el" href="classorbtree_1_1orbtree.html#a4784ea629f4d659da78d37198a895be0" title="return an iterator to the first element with key greater than k ">upper_bound()</a> if the beginning or end of a range is required. </p>

</div>
</div>
<a id="a18ff8f91ead2292f426e0e0f6c61994a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ff8f91ead2292f426e0e0f6c61994a">&#9670;&nbsp;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator, class Compare, class NVFunc, bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a> <a class="el" href="classorbtree_1_1orbtree.html">orbtree::orbtree</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classorbtree_1_1orbtree.html#a872823d333cf4224dedb47015117858e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>iteraror that allows the modification of the stored value (for maps) <a class="el" href="classorbtree_1_1orbtree.html#afa72432f83b56e4b48e2104113586c48" title="Find an element with the given key and return an iterator to it. ">find(const key_type&amp; k)</a> </p>
<p><a class="el" href="classorbtree_1_1orbtree.html#afa72432f83b56e4b48e2104113586c48" title="Find an element with the given key and return an iterator to it. ">find(const key_type&amp; k)</a> Returns const iterator for const tree. </p>

</div>
</div>
<a id="ac6e25c75f89126d0bd623f200dc09ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e25c75f89126d0bd623f200dc09ad0">&#9670;&nbsp;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator, class Compare, class NVFunc, bool multi&gt; </div>
<div class="memtemplate">
template&lt;class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a> <a class="el" href="classorbtree_1_1orbtree.html">orbtree::orbtree</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>iteraror that allows the modification of the stored value (for maps) <a class="el" href="classorbtree_1_1orbtree.html#afa72432f83b56e4b48e2104113586c48" title="Find an element with the given key and return an iterator to it. ">find(const key_type&amp; k)</a> </p>
<p><a class="el" href="classorbtree_1_1orbtree.html#afa72432f83b56e4b48e2104113586c48" title="Find an element with the given key and return an iterator to it. ">find(const key_type&amp; k)</a> Works for any type K that is comparable to the keys. </p>

</div>
</div>
<a id="a6e517ba03db468a5e55069c223d57ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e517ba03db468a5e55069c223d57ee8">&#9670;&nbsp;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator, class Compare, class NVFunc, bool multi&gt; </div>
<div class="memtemplate">
template&lt;class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a> <a class="el" href="classorbtree_1_1orbtree.html">orbtree::orbtree</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>iteraror that allows the modification of the stored value (for maps) <a class="el" href="classorbtree_1_1orbtree.html#afa72432f83b56e4b48e2104113586c48" title="Find an element with the given key and return an iterator to it. ">find(const key_type&amp; k)</a> </p>
<p><a class="el" href="classorbtree_1_1orbtree.html#afa72432f83b56e4b48e2104113586c48" title="Find an element with the given key and return an iterator to it. ">find(const key_type&amp; k)</a> Works for any type K that is comparable to the keys.</p>
<p>Returns const iterator for const tree. </p>

</div>
</div>
<a id="acaa20acf7d4971e12efe16741ddda9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa20acf7d4971e12efe16741ddda9f1">&#9670;&nbsp;</a></span>get_sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator, class Compare, class NVFunc, bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorbtree_1_1orbtree.html">orbtree::orbtree</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::get_sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classorbtree_1_1orbtree.html#a872823d333cf4224dedb47015117858e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree.html#a67c62695054716e369a4a9e370d5afb0">NVType</a> *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate partial sum for keys that come before k. </p>
<p>Result is returned in res, which must point to an array large enough (with elements corresponding to the number of components returned by NVFunc). </p>

</div>
</div>
<a id="a5ec3439e4356708dcf188eda51997c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec3439e4356708dcf188eda51997c30">&#9670;&nbsp;</a></span>get_sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator, class Compare, class NVFunc, bool multi&gt; </div>
<div class="memtemplate">
template&lt;class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorbtree_1_1orbtree.html">orbtree::orbtree</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::get_sum </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree.html#a67c62695054716e369a4a9e370d5afb0">NVType</a> *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate partial sum for keys that come before k. </p>
<p>Result is returned in res, which must point to an array large enough (with elements corresponding to the number of components returned by NVFunc). </p>

</div>
</div>
<a id="ae182a2bbfc881111c60231aff335457b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae182a2bbfc881111c60231aff335457b">&#9670;&nbsp;</a></span>get_sum_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator, class Compare, class NVFunc, bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classorbtree_1_1orbtree.html">orbtree::orbtree</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::get_sum_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree.html#a67c62695054716e369a4a9e370d5afb0">NVType</a> *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate partial sum of the values stored in nodes that come before the one pointed to by it. </p>
<p>Result is returned in res, which must point to an array large enough (e.g. with at least as many elements as the components calculated by NVFunc) </p>

</div>
</div>
<a id="adfda6c14a1a6370843a46a196107f528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfda6c14a1a6370843a46a196107f528">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator, class Compare, class NVFunc, bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorbtree_1_1orbtree.html#a552618d05b82e96fe8914eb484ebed09">insert_type</a> <a class="el" href="classorbtree_1_1orbtree.html">orbtree::orbtree</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classorbtree_1_1orbtree.html#a881f04f49d41692ff98d8bda444f9a43">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert new element. </p>
<p>For non-multi map/set, the return type is std::pair&lt;iterator,bool&gt;, where the second element indicates if insert was successful. If an element with the same key already existed, the insert fails and false is returned.</p>
<p>For multi map/set, inserting always succeeds and the return type is an iterator to the new element. In this case, a new element is always inserted after any existing elements with the same key </p>

</div>
</div>
<a id="aced8846c22739f2af9f3b8d14311d406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced8846c22739f2af9f3b8d14311d406">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator, class Compare, class NVFunc, bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorbtree_1_1orbtree.html#a552618d05b82e96fe8914eb484ebed09">insert_type</a> <a class="el" href="classorbtree_1_1orbtree.html">orbtree::orbtree</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree.html#a881f04f49d41692ff98d8bda444f9a43">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert new element. </p>
<p>For non-multi map/set, the return type is std::pair&lt;iterator,bool&gt;, where the second element indicates if insert was successful. If an element with the same key already existed, the insert fails and false is returned.</p>
<p>For multi map/set, inserting always succeeds and the return type is an iterator to the new element. In this case, a new element is always inserted after any existing elements with the same key </p>

</div>
</div>
<a id="a7431e41d04a66f8d2859dc943c9e8073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7431e41d04a66f8d2859dc943c9e8073">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator, class Compare, class NVFunc, bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a> <a class="el" href="classorbtree_1_1orbtree.html">orbtree::orbtree</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classorbtree_1_1orbtree.html#a881f04f49d41692ff98d8bda444f9a43">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert new element with hint. </p>
<p>Caller suggests a position which is before the element pointed to by the supplied iterator.</p>
<p>For non-multi tree (map/set; i.e. duplicates are not allowed):</p><ul>
<li>if the hint points to the correct position (i.e. the new element should go before the element referenced by the hint iterator), then a search is not performed, so the insertion cost is amortized constant</li>
<li>in all other cases, the hint is ignored</li>
</ul>
<p>For multi tree (duplicate keys are allowed):</p><ul>
<li>if the key is equal to the key of element referenced by the hint iterator, then the new element is inserted before it</li>
<li>otherwise, the new element is inserted as close as possible </li>
</ul>

</div>
</div>
<a id="ac032f9edef7bb64542a59c365732965e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac032f9edef7bb64542a59c365732965e">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator, class Compare, class NVFunc, bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorbtree_1_1orbtree.html#ae617d1a2aca440829f85d16cf97a0a6f">iterator</a> <a class="el" href="classorbtree_1_1orbtree.html">orbtree::orbtree</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree.html#a2bdfea1e7580d7c43ad8d62816c9461e">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorbtree_1_1orbtree.html#a881f04f49d41692ff98d8bda444f9a43">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>iteraror that allows the modification of the stored value (for maps) <a class="el" href="classorbtree_1_1orbtree.html#a7431e41d04a66f8d2859dc943c9e8073" title="Insert new element with hint. ">insert(const_iterator hint, const value_type&amp; v)</a> </p>
<p><a class="el" href="classorbtree_1_1orbtree.html#a7431e41d04a66f8d2859dc943c9e8073" title="Insert new element with hint. ">insert(const_iterator hint, const value_type&amp; v)</a> </p>

</div>
</div>
<a id="a1c0d0269732f7b8d9a699789bc615587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0d0269732f7b8d9a699789bc615587">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeAllocator, class Compare, class NVFunc, bool multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classorbtree_1_1orbtree.html">orbtree::orbtree</a>&lt; NodeAllocator, Compare, NVFunc, multi &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the maximum possible number of elements </p>
<p>return the number of elemets </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="orbtree_8h_source.html">orbtree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
