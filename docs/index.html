<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>orbtree: Generalized order-statistic tree implementation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">orbtree
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Generalized order-statistic tree implementation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>An <a href="https://en.wikipedia.org/wiki/Order_statistic_tree">order statistic tree</a> is a binary search tree where the rank of any element can be calculated efficiently (in O(log n) time). This is achieved by taking a balanced binary tree (a red-black tree in this case) and augmenting each node with additional information about the size of its subtree.</p>
<p>A generalized order statistic tree allows the efficient calculation of a partial sum of an arbitrary function, </p><div class="image">
<object type="image/svg+xml" data="img/fkv.svg" alt="f(k,v)"></object>
</div>
<p> in general depending on the keys and values stored in the tree: </p><div class="image">
<object type="image/svg+xml" data="img/partialsum.svg" alt="\sum_{k &lt; K} f(k,v)"></object>
</div>
<p>The special case </p><div class="image">
<object type="image/svg+xml" data="img/fkv1.svg" alt="f(k,v) \equiv 1"></object>
</div>
<p> gives back a regular order-statistic tree. In the following, I refer to this function as the <em>weight</em> function and the value it returns as the weight of an element. Efficient calculation of the sum of weights can be achieved by storing partial sums in the nodes of a binary tree. In this case, each node stores the partial sum for its subtree.</p>
<p>This repository contains a C++ template implementation of a generalized order statistic tree, implementing functionality similar to <a href="https://en.cppreference.com/w/cpp/container/set">sets</a>, <a href="https://en.cppreference.com/w/cpp/container/multiset">multisets</a>, <a href="https://en.cppreference.com/w/cpp/container/map">maps</a> and <a href="https://en.cppreference.com/w/cpp/container/multimap">multimaps</a> from the standard library.</p>
<p>Example code using this library is available at <a href="https://github.com/dkondor/patest_new,">https://github.com/dkondor/patest_new,</a> implementing testing for preferential attachment in growing networks (according to our paper <a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0086197">Do the Rich Get Richer? An Empirical Analysis of the Bitcoin Transaction Network</a>).</p>
<h2>Usage</h2>
<p>To use this library, put the main header files (<a class="el" href="orbtree_8h_source.html">orbtree.h</a>, <a class="el" href="orbtree__base_8h_source.html">orbtree_base.h</a>, <a class="el" href="orbtree__node_8h_source.html">orbtree_node.h</a>, <a class="el" href="vector__realloc_8h_source.html">vector_realloc.h</a>, <a class="el" href="vector__stacked_8h_source.html">vector_stacked.h</a>) in your source tree and include <code><a class="el" href="orbtree_8h_source.html">orbtree.h</a></code> in your project. Each container type has four implementations, according to the following two choices:</p>
<ul>
<li>Whether the weight function returns only one value (simple), or returns a vector of values (vector). The latter case can be especially useful if the goal is to evaluate the same function with multiple parameter values.</li>
<li>Whether the implementation allocated individual nodes separately and uses pointers internally, or stores nodes in vector-like containers and uses indexes internally to refer to nodes. The latter choice provides a more compact tree with less memeory allocation, and for trees with less than 2^31-1 elements, it allows the use of 32-bit indexes instead of 64-bit pointers &ndash; this can in turn decrease memory use as well.</li>
</ul>
<p>These implementations are provided by the following classes (all part of the <code>orbtree</code> namespace:</p>
<table class="doxtable">
<tr>
<th></th><th>Pointer-based storage </th><th>Compact storage  </th></tr>
<tr>
<td>Weight function return scalar value </td><td><a class="el" href="classorbtree_1_1simple__set.html">simple_set</a>, <a class="el" href="classorbtree_1_1simple__multiset.html">simple_multiset</a>, <a class="el" href="classorbtree_1_1simple__map.html">simple_map</a>, <a class="el" href="classorbtree_1_1simple__multimap.html">simple_multimap</a> </td><td><a class="el" href="classorbtree_1_1simple__setC.html">simple_setC</a>, <a class="el" href="classorbtree_1_1simple__multisetC.html">simple_multisetC</a>, <a class="el" href="classorbtree_1_1simple__mapC.html">simple_mapC</a>, <a class="el" href="classorbtree_1_1simple__multimapC.html">simple_multimapC</a> </td></tr>
<tr>
<td>Weight function returns vector </td><td><a class="el" href="classorbtree_1_1orbset.html">orbset</a>, <a class="el" href="classorbtree_1_1orbmultiset.html">orbmultiset</a>, <a class="el" href="classorbtree_1_1orbmap.html">orbmap</a>, <a class="el" href="classorbtree_1_1orbmultimap.html">orbmultimap</a> </td><td><a class="el" href="classorbtree_1_1orbsetC.html">orbsetC</a>, <a class="el" href="classorbtree_1_1orbmultisetC.html">orbmultisetC</a>, <a class="el" href="classorbtree_1_1orbmapC.html">orbmapC</a>, <a class="el" href="classorbtree_1_1orbmultimapC.html">orbmultimapC</a> </td></tr>
</table>
<p>The main interface for the above is actually provided by the <a class="el" href="classorbtree_1_1orbtree.html" title="Generalized order statistic tree main interface. It is recommended to use the templates orbset...">orbtree::orbtree</a> and <a class="el" href="classorbtree_1_1orbtreemap.html" title="Base class with map-specific function. It is recommended to use the specializations simple_map...">orbtree::orbtreemap</a> classes, but it is recommended to not instantiate these directly, but use the wrappers (which are actually <code>using</code> template definitions with the appropriate parameter values).</p>
<p><b>Note</b>: a main difference from STL maps is that values cannot be directly set by the reference returned by <a class="el" href="classorbtree_1_1orbtreemap.html#ab1bc5c6223237dcb88adc35137004586">map::at()</a> or <a class="el" href="classorbtree_1_1orbtreemap.html#ac6589c21a2b662426486e75046edf11f">operator []</a> or by <a class="el" href="structorbtree_1_1orbtree_1_1iterator__base.html#a3f6d1e3f42908de9dff56b8cf5786ece">dereferencing iterators</a>. The reason for this is that setting a value can require recomputing the internal function values that depend on it. Use one of the <a class="el" href="classorbtree_1_1orbtreemap.html#a203b1dd0e1834e71c38258bda179ae49">set_value()</a> or <a class="el" href="classorbtree_1_1orbtreemap.html#a2170e391bc8d51302f9208ef02b0967d">update_value() or the  orbtree::orbtree::iterator_base::set_value() </a>iterator::set_value() functions instead.</p>
<p>What is needed for all cases is to provide a function object that can compute the values associated with the elements stored in the container (whose sum is calculated). For more generality, this function can either return a scalar (to be used be the <code>simple_</code> variants) or be vector-valued, e.g. to compute results with different parameter values using the same tree.</p>
<p>The expected interface is documented as <a class="el" href="structorbtree_1_1NVFunc__Adapter__Simple.html" title="Adapter for functions that return only one result. This class also describes the interface expected f...">orbtree::NVFunc_Adapter_Simple</a>; also, if you would like to use a function that returns a single value, you can use the wrapper <a class="el" href="structorbtree_1_1NVFunc__Adapter__Simple.html" title="Adapter for functions that return only one result. This class also describes the interface expected f...">orbtree::NVFunc_Adapter_Simple</a>.</p>
<p>A simple example is the following for a function that adds and doubles the key and value (which are both unsigned integers):</p>
<div class="fragment"><div class="line">// define function to use</div><div class="line">struct double_add {</div><div class="line">    typedef std::pair&lt;unsigned int, unsigned int&gt; argument_type;</div><div class="line">    typedef unsigned int result_type;</div><div class="line">    unsigned int operator()(const std::pair&lt;unsigned int, unsigned int&gt;&amp; p) const {</div><div class="line">        return 2*(p.first + p.second);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">// map with the above function</div><div class="line">orbtree::simple_map&lt;unsigned int, unsigned int, double_add &gt; map1;</div><div class="line"></div><div class="line">// insert elements</div><div class="line">map1.insert(std::make_pair(1U,2U));</div><div class="line">map1.insert(std::make_pair(1000U,1234U));</div><div class="line">// ...</div><div class="line">// calculate sum of function for element with key == 1000</div><div class="line">unsigned int res = map1.get_sum(1000U);</div></div><!-- fragment --><p>A more detailed example with a vector function that multiplies the key with the given parameter and a map that actually stores a "histogram", thus weights need to be multiplied by the value of nodes: </p><div class="fragment"><div class="line">// function to use</div><div class="line">struct mult_hist {</div><div class="line">    typedef std::pair&lt;unsigned int, unsigned int&gt; argument_type;</div><div class="line">    typedef double ParType;</div><div class="line">    typedef double result_type;</div><div class="line">    double operator()(const std::pair&lt;unsigned int, unsigned int&gt;&amp; p, double a) const {</div><div class="line">        return a*p.first*p.second;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>When declaring the tree, it is possible to use the <a class="el" href="structorbtree_1_1NVFunc__Adapter__Vec.html" title="adapter for functions that take one parameter from a vector of parameters ">orbtree::NVFunc_Adapter_Vec</a> adapter and also to give a vector of parameter values to the tree constructor. When calculating weights, the weight function will be called with each parameter value. </p><div class="fragment"><div class="line">std::vector&lt;double&gt; parameters{1.0,2.5,5.555555};</div><div class="line">orbtree::orbmapC&lt;unsigned int, unsigned int, orbtree::NVFunc_Adapter_Vec&lt;mult_hist&gt; &gt; map2(parameters);</div></div><!-- fragment --><p>Insert elements as normal: </p><div class="fragment"><div class="line">map2.insert(std::make_pair(1U,3U);</div><div class="line">map2.insert(std::make_pair(10U,1U);</div><div class="line">map2.insert(std::make_pair(5U,2U);</div></div><!-- fragment --><p>Calculation of weights now requires an appropriately sized array: </p><div class="fragment"><div class="line">std::vector&lt;double&gt; sum1(parameters.size());</div><div class="line">std::vector&lt;double&gt; norm(parameters.size());</div><div class="line">map2.get_sum(10,tmp.data());</div><div class="line">map2.get_norm(norm.data());</div></div><!-- fragment --><p>Note: it is not possible to modify mapped values directly or with iterators, e.g. the following will not compile: </p><div class="fragment"><div class="line">map2[1] = 5;</div><div class="line">map2[10]++;</div><div class="line">auto it = map2.find(5);</div><div class="line">it-&gt;second = 1;</div></div><!-- fragment --><p> It is possible to use <a class="el" href="classorbtree_1_1orbtreemap.html#a203b1dd0e1834e71c38258bda179ae49">map::set_value()</a> or <a class="el" href="classorbtree_1_1orbtreemap.html#a2170e391bc8d51302f9208ef02b0967d">map::update_value()</a> to modify the values, e.g.: </p><div class="fragment"><div class="line">map2.update_value(1,5);</div><div class="line">map2.set_value(11,1);</div></div><!-- fragment --><p> Note that the diffence between the two is that <a class="el" href="classorbtree_1_1orbtreemap.html#a2170e391bc8d51302f9208ef02b0967d">map::update_value()</a> requires the key to be already present, i.e. it will throw an exception if called with a key not present in the map. On the other hand, <a class="el" href="classorbtree_1_1orbtreemap.html#a203b1dd0e1834e71c38258bda179ae49">map::set_value()</a> will insert a new element if the key is not present (if the key is present, it will update the value &ndash; of course, you can use <a class="el" href="classorbtree_1_1orbtree.html#ab810d2bd674ee1a7fea099b9a69f6243">insert()</a> to only insert a new value if the key is not yet present in a map). Also, values can be updated using iterators: </p><div class="fragment"><div class="line">auto it = map2.find(5);</div><div class="line">it.set_value(1);</div></div><!-- fragment --><p> Note that <a class="el" href="structorbtree_1_1orbtree_1_1iterator__base.html#ad01d36bed41472b0fabed04e963eef4a">iterator::set_value()</a> is present for both maps and multimaps, so it can be used to update values in a multimap as well. Read-only access is still possible the usual way, e.g.: </p><div class="fragment"><div class="line">unsigned int x = map2[1];</div><div class="line">unsigned int y = map2[10];</div><div class="line">auto it = map2.find(5);</div><div class="line">unsigned int z = it-&gt;second;</div></div><!-- fragment --><p> Note that if called with a non-existent key, <a class="el" href="classorbtree_1_1orbtreemap.html#ac6589c21a2b662426486e75046edf11f">orbtree::orbtreemap::operator[]()</a> "operator []" will still insert a new element with the default value, similar to <a href="https://en.cppreference.com/w/cpp/container/map/operator_at">std::map</a>.</p>
<h2>Details</h2>
<p>There are two types of implementations (defined in <a class="el" href="orbtree__node_8h_source.html">orbtree_node.h</a>) which differ in how they allocate memory. The pointer-based version (using <a class="el" href="classorbtree_1_1NodeAllocatorPtr.html" title="Basic allocator that allocates each node individually, using C++ new / delete and pointers...">orbtree::NodeAllocatorPtr</a>) allocates each node separately and stores pointer to child and parent nodes and is used for the variants <a class="el" href="classorbtree_1_1simple__set.html">simple_set</a>, <a class="el" href="classorbtree_1_1simple__multiset.html">simple_multiset</a>, <a class="el" href="classorbtree_1_1simple__map.html">simple_map</a>, <a class="el" href="classorbtree_1_1simple__multimap.html">simple_multimap</a> and <a class="el" href="classorbtree_1_1orbset.html">orbset</a>, <a class="el" href="classorbtree_1_1orbmultiset.html">orbmultiset</a>, <a class="el" href="classorbtree_1_1orbmap.html">orbmap</a>, <a class="el" href="classorbtree_1_1orbmultimap.html">orbmultimap</a>. Also, for the non-simple versions, it dynamically allocates storage for the vector of computed partial sums of weights. The advantage of this is simplicity and that only the exact amount of memory needed for storage is allocated and memory is freed instantly when removing elements. It is also recommended to use this implementation for containers that are expected to store a moderate number of large objects (thus the overhead of storing pointers is small compared to the stored object size).</p>
<p>An alternative implementation (using <a class="el" href="classorbtree_1_1NodeAllocatorCompact.html" title="Alternate node allocator with the aim to use less memory. ">orbtree::NodeAllocatorCompact</a>) stores nodes in flat arrays (special vectors) and is used for the variants <a class="el" href="classorbtree_1_1simple__setC.html">simple_setC</a>, <a class="el" href="classorbtree_1_1simple__multisetC.html">simple_multisetC</a>, <a class="el" href="classorbtree_1_1simple__mapC.html">simple_mapC</a>, <a class="el" href="classorbtree_1_1simple__multimapC.html">simple_multimapC</a> and <a class="el" href="classorbtree_1_1orbsetC.html">orbsetC</a>, <a class="el" href="classorbtree_1_1orbmultisetC.html">orbmultisetC</a>, <a class="el" href="classorbtree_1_1orbmapC.html">orbmapC</a>, <a class="el" href="classorbtree_1_1orbmultimapC.html">orbmultimapC</a>. One main advantage is that instead of storing raw pointers, it is possible to store indexes into this array. On a 64-bit machine, using only 32-bit indexes can save a significant amount of memory, assuming that the number of elements stored does not exceed 2^32. Furthermore, the red-black flag is stored in the parent index, reducing the maximum size to 2^31-1, but decreasing the size of nodes (typically by 1 byte, but up to 4 bytes practically due to padding). In this case, memory is allocated in larger chunks instead of individually for nodes; in some cases, this can increase performance as well. The partial sums of the node weights are stored separately, simplifying node structure further and avoiding dynamic memory allocation for each node.</p>
<p>The main disadvantage is the vector implementation to use. Instead of std::vector (that can be wasteful with memory), two special implementations (<a class="el" href="classrealloc__vector_1_1vector.html" title="C++ vector-like container for trivially moveable types, using realloc() for growing memory...">realloc_vector::vector</a> and <a class="el" href="classstacked__vector_1_1vector.html" title="C++ vector-like container that internally maintains a &quot;stack&quot; of vectors instead of having one large ...">stacked_vector::vector</a>) are used that have linear growth, thus are less likely to cause out-of-memory errors. The first one (<a class="el" href="classrealloc__vector_1_1vector.html" title="C++ vector-like container for trivially moveable types, using realloc() for growing memory...">realloc_vector::vector</a>) relies on having an efficient implementation of <a href="https://en.cppreference.com/w/c/memory/realloc">realloc()</a> available and only works for key and value types that are <a href="https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable">trivially copyable</a> (essentially any type that can be moved to a different memory location without issues). For general types, a second option is used (<a class="el" href="classstacked__vector_1_1vector.html" title="C++ vector-like container that internally maintains a &quot;stack&quot; of vectors instead of having one large ...">stacked_vector::vector</a>) that maintains a stack of vectors. This implementation can be significantly slower due to a lot of integer division operations necessary to access elements. This can be sped up by using the <a href="https://github.com/ridiculousfish/libdivide">libdivide</a> library, that can be enabled by defining USE_LIBDIVIDE. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
