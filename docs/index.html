<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>orbtree: Generalized order-statistic tree implementation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">orbtree
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Generalized order-statistic tree implementation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>An <a href="https://en.wikipedia.org/wiki/Order_statistic_tree">order statistic tree</a> is a binary search tree where the rank of any element can be calculated efficiently (in O(log n) time). This is achieved by taking a balanced binary tree (a red-black tree in this case) and augmenting each node with additional information about the size of its subtree.</p>
<p>A generalized order statistic tree allows the efficient calculation of a partial sum of an arbitrary function, </p><div class="image">
<object type="image/svg+xml" data="img/fkv.svg" alt="f(k,v)"></object>
</div>
<p> in general depending on the keys and values stored in the tree: </p><div class="image">
<object type="image/svg+xml" data="img/partialsum.svg" alt="\sum_{k &lt; K} f(k,v)"></object>
</div>
<p>The special case </p><div class="image">
<object type="image/svg+xml" data="img/fkv1.svg" alt="f(k,v) \equiv 1"></object>
</div>
<p> gives back a regular order-statistic tree.</p>
<p>This repository contains a C++ template implementation of a generalized order statistic tree, implementing functionality similar to <a href="https://en.cppreference.com/w/cpp/container/set">sets</a>, <a href="https://en.cppreference.com/w/cpp/container/multiset">multisets</a>, <a href="https://en.cppreference.com/w/cpp/container/map">maps</a> and <a href="https://en.cppreference.com/w/cpp/container/multimap">multimaps</a> from the standard library.</p>
<h2>Usage</h2>
<p>This library requires a C++11 compiler (it was tested on g++).</p>
<p>To use this library, put the main header files (<a class="el" href="orbtree_8h_source.html">orbtree.h</a>, <a class="el" href="orbtree__base_8h_source.html">orbtree_base.h</a>, <a class="el" href="orbtree__node_8h_source.html">orbtree_node.h</a>, <a class="el" href="vector__realloc_8h_source.html">vector_realloc.h</a>, <a class="el" href="vector__stacked_8h_source.html">vector_stacked.h</a>) in your source tree and include <a class="el" href="orbtree_8h_source.html">orbtree.h</a> in your project. Use one of the following classes according to the needs of your project: <a class="el" href="classorbtree_1_1orbset.html" title="General set, i.e. storing a collection of elements without duplicates. See orbtree::orbtree for descr...">orbtree::orbset</a>, <a class="el" href="classorbtree_1_1orbmultiset.html" title="General multiset, i.e. storing a collection of elements allowing duplicates. See orbtree::orbtree for...">orbtree::orbmultiset</a>, <a class="el" href="classorbtree_1_1orbmap.html" title="General map implementation. See orbtree and orbtreemap for description of members. ">orbtree::orbmap</a> and <a class="el" href="classorbtree_1_1orbmultimap.html" title="General multimap implementation (i.e. map allowing duplicate keys). See orbtree for description of me...">orbtree::orbmultimap</a> provide the functionaility of sets, multisets, maps and multimaps respectively. Alternatively, the variants <a class="el" href="classorbtree_1_1orbsetC.html" title="Specialized set with compact storage, for POD (trivially copyable) elements. See orbtree::orbtree for...">orbtree::orbsetC</a>, <a class="el" href="classorbtree_1_1orbmultisetC.html" title="Specialized multiset with compact storage, for POD (trivially copyable) elements. See orbtree::orbtre...">orbtree::orbmultisetC</a>, <a class="el" href="classorbtree_1_1orbmapC.html" title="Map implementation with compact storage. See orbtree and orbtreemap for description of members...">orbtree::orbmapC</a> and <a class="el" href="classorbtree_1_1orbmultimapC.html" title="Multimap implementation with compact storage. See orbtree for description of members. Key and value must be POD-types. ">orbtree::orbmultimapC</a> provide the same functionality using a more compact form of storage with less memory use, especially if the expected number of elements is below 2^31-1 (approximately 2 billion elements).</p>
<p>The main interface for the above classes is actually provided by the <a class="el" href="classorbtree_1_1orbtree.html" title="Generalized order statistic tree main interface. It is recommended to use the templates orbset...">orbtree::orbtree</a> and <a class="el" href="classorbtree_1_1orbtreemap.html" title="Base class with map-specific function. It is recommended to use the specializations orbmap...">orbtree::orbtreemap</a> classes, but it is recommended to not instantiate these directly, but use the wrappers (which are simple using template definitions with the appropriate parameter values).</p>
<p><b>Note</b>: a main difference from STL maps is that values cannot be directly set by the reference returned by <a class="el" href="classorbtree_1_1orbtreemap.html#a164910d455232d83cca86c4dfd18e64d">map::at()</a> or <a class="el" href="classorbtree_1_1orbtreemap.html#a36010840bfc431a36bb5ef6c9881d314">operator []</a> or by <a class="el" href="structorbtree_1_1orbtree_1_1iterator__base.html#a3a4fafd27b6a15b8526f2fbeb6c9b6f8">dereferencing iterators</a>. The reason for this is that setting a value can require recomputing the internal function values that depend on it. Use one of the <a class="el" href="classorbtree_1_1orbtreemap.html#aca93218a61534544c32a404f43d02263">set_value()</a> or <a class="el" href="classorbtree_1_1orbtreemap.html#a17e509af03af8ec20b5733abbc727225">update_value() or the  orbtree::orbtree::iterator_base::set_value() </a>iterator::set_value() functions instead.</p>
<p>What is needed for all cases is to provide a function object that can compute the values associated with the elements stored in the container (whose sum is calculated). For more generality, this function is assumed to compute a vector of values (e.g. to be able to run any calculation with different parameters at the same time). The expected interface is documented as <a class="el" href="structorbtree_1_1NVFunc__Adapter__Simple.html" title="Adapter for functions that return only one result. ">orbtree::NVFunc_Adapter_Simple</a>; also, if you would like to use a function that returns a single value, you can use the wrapper <a class="el" href="structorbtree_1_1NVFunc__Adapter__Simple.html" title="Adapter for functions that return only one result. ">orbtree::NVFunc_Adapter_Simple</a>. If you would like to do the calculations with a function that returns a single value and takes one parameter for multiple parameter values, you can use <a class="el" href="structorbtree_1_1NVFunc__Adapter__Vec.html" title="adapter for functions that take one parameter from a vector of parameters ">orbtree::NVFunc_Adapter_Vec</a>.</p>
<p>A simple example is the following for a function that adds and doubles the key and value (which are both unsigned integers):</p>
<div class="fragment"><div class="line">// define function to use</div><div class="line">struct double_add {</div><div class="line">    typedef std::pair&lt;unsigned int, unsigned int&gt; argument_type;</div><div class="line">    typedef unsigned int result_type;</div><div class="line">    unsigned int operator()(const std::pair&lt;unsigned int, unsigned int&gt;&amp; p) const {</div><div class="line">        return 2*(p.first + p.second);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">// map with the above function</div><div class="line">orbtree::orbmap&lt;unsigned int, unsigned int, orbtree::NVFunc_Adapter_Simple&lt; double_add &gt; &gt; map1;</div><div class="line"></div><div class="line">// insert elements</div><div class="line">map1.insert(std::make_pair(1U,2U));</div><div class="line">map1.insert(std::make_pair(1000U,1234U));</div><div class="line">// ...</div><div class="line">// calculate sum of function for element with key == 1000</div><div class="line">unsigned int res;</div><div class="line">map1.get_sum(1000U,&amp;res);</div></div><!-- fragment --><h2>Details</h2>
<p>There are two types of implementations (defined in <a class="el" href="orbtree__node_8h_source.html">orbtree_node.h</a>) which differ in how they allocate memory. The simple version (using <a class="el" href="classorbtree_1_1NodeAllocatorPtr.html" title="Basic allocator that allocates each node individually, using C++ new / delete and pointers...">orbtree::NodeAllocatorPtr</a>) allocates each node separately and stores pointer to child and parent nodes and is used for the variants <a class="el" href="classorbtree_1_1orbset.html" title="General set, i.e. storing a collection of elements without duplicates. See orbtree::orbtree for descr...">orbtree::orbset</a>, <a class="el" href="classorbtree_1_1orbmultiset.html" title="General multiset, i.e. storing a collection of elements allowing duplicates. See orbtree::orbtree for...">orbtree::orbmultiset</a>, <a class="el" href="classorbtree_1_1orbmap.html" title="General map implementation. See orbtree and orbtreemap for description of members. ">orbtree::orbmap</a> and <a class="el" href="classorbtree_1_1orbmultimap.html" title="General multimap implementation (i.e. map allowing duplicate keys). See orbtree for description of me...">orbtree::orbmultimap</a>. Also, it dynamically allocates storage to the vector of computed value / partial sums. The advantage of this is simplicity and that only the exact amount of memory needed for storage is allocated and memory is freed instantly when removing elements. It is also recommended to use this implementation for containers that are expected to store a moderate number of large objects (thus the overhead of storing pointers is small compared to the stored object size).</p>
<p>An alternative implementation (using <a class="el" href="classorbtree_1_1NodeAllocatorCompact.html" title="Alternate node allocator with the aim to use less memory. ">orbtree::NodeAllocatorCompact</a>) stores nodes in flat arrays (special vectors) and is used for the variants <a class="el" href="classorbtree_1_1orbsetC.html" title="Specialized set with compact storage, for POD (trivially copyable) elements. See orbtree::orbtree for...">orbtree::orbsetC</a>, <a class="el" href="classorbtree_1_1orbmultisetC.html" title="Specialized multiset with compact storage, for POD (trivially copyable) elements. See orbtree::orbtre...">orbtree::orbmultisetC</a>, <a class="el" href="classorbtree_1_1orbmapC.html" title="Map implementation with compact storage. See orbtree and orbtreemap for description of members...">orbtree::orbmapC</a> and <a class="el" href="classorbtree_1_1orbmultimapC.html" title="Multimap implementation with compact storage. See orbtree for description of members. Key and value must be POD-types. ">orbtree::orbmultimapC</a>. One main advantage is that instead of storing raw pointers, it is possible to store indexes into this array. On a 64-bit machine, using only 32-bit indexes can save a significant amount of memory, assuming that the number of elements stored does not exceed 2^32. Furthermore, the red-black flag is stored in the parent index, reducing the maximum size to 2^31-1, but further decreasing the size of nodes (typically by 1 byte, but up to 4 bytes practically due to padding). In this case, memory is allocated in larger chunks instead of individually for nodes; in some cases, this can increase performance as well. The partial sum of the values generated by the function from the keys and values are stored separately, simplifying node structure further.</p>
<p>The main disadvantage is the vector implementation to use. Instead of std::vector (that can be wasteful with memory), two special implementations (<a class="el" href="classrealloc__vector_1_1vector.html" title="C++ vector-like container for trivially moveable types, using realloc() for growing memory...">realloc_vector::vector</a> and <a class="el" href="classstacked__vector_1_1vector.html" title="C++ vector-like container that internally maintains a &quot;stack&quot; of vectors instead of having one large ...">stacked_vector::vector</a>) are used that have linear growth, thus are less likely to cause out-of-memory errors. The first one (<a class="el" href="classrealloc__vector_1_1vector.html" title="C++ vector-like container for trivially moveable types, using realloc() for growing memory...">realloc_vector::vector</a>) relies on having an efficient implementation of <a href="https://en.cppreference.com/w/c/memory/realloc">realloc()</a> available and only works for key and value types that are <a href="https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable">trivially copyable</a> (essentially any type that can be moved to a different memory location without issues). For general types, a second option is used (<a class="el" href="classstacked__vector_1_1vector.html" title="C++ vector-like container that internally maintains a &quot;stack&quot; of vectors instead of having one large ...">stacked_vector::vector</a>) that maintains a stack of vectors. This implementation can be significantly slower due to a lot of integer division operations necessary to access elements. This can be sped up by using the <a href="https://github.com/ridiculousfish/libdivide">libdivide</a> library, that can be enabled by defining USE_LIBDIVIDE. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
