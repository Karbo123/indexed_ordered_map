<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>orbtree: stacked_vector::vector&lt; T, vector_type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">orbtree
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>stacked_vector</b></li><li class="navelem"><a class="el" href="classstacked__vector_1_1vector.html">vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classstacked__vector_1_1vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">stacked_vector::vector&lt; T, vector_type &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>C++ vector-like container that internally maintains a "stack" of vectors instead of having one large resizeable storage.  
 <a href="classstacked__vector_1_1vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vector__stacked_8h_source.html">vector_stacked.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators store a reference to this class and a position.  <a href="classstacked__vector_1_1vector_1_1iterator__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2adbebaf54de0dec70518e24ad99855a"><td class="memItemLeft" align="right" valign="top"><a id="a2adbebaf54de0dec70518e24ad99855a"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a2adbebaf54de0dec70518e24ad99855a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c4fdb9d7f53803c5a73d24b4c0e945"><td class="memItemLeft" align="right" valign="top"><a id="a87c4fdb9d7f53803c5a73d24b4c0e945"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a87c4fdb9d7f53803c5a73d24b4c0e945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7472596ea5820d3adf412b4f80fddf83"><td class="memItemLeft" align="right" valign="top"><a id="a7472596ea5820d3adf412b4f80fddf83"></a>
typedef ssize_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a7472596ea5820d3adf412b4f80fddf83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95a021fcb238ce62b005c0a22bc57ec"><td class="memItemLeft" align="right" valign="top"><a id="ad95a021fcb238ce62b005c0a22bc57ec"></a>
typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:ad95a021fcb238ce62b005c0a22bc57ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c4f3940d40c506d552f98964bf4006"><td class="memItemLeft" align="right" valign="top"><a id="a48c4f3940d40c506d552f98964bf4006"></a>
typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:a48c4f3940d40c506d552f98964bf4006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17381379bb9470f3316110a5cf973f7c"><td class="memItemLeft" align="right" valign="top"><a id="a17381379bb9470f3316110a5cf973f7c"></a>
typedef T *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a17381379bb9470f3316110a5cf973f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b19c44ec8e9ac8cafff8be98f0910c"><td class="memItemLeft" align="right" valign="top"><a id="ac6b19c44ec8e9ac8cafff8be98f0910c"></a>
typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:ac6b19c44ec8e9ac8cafff8be98f0910c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2fa82487f81cfd3379509c1fa55f66"><td class="memItemLeft" align="right" valign="top"><a id="a9f2fa82487f81cfd3379509c1fa55f66"></a>
typedef <a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator_base</a>&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a9f2fa82487f81cfd3379509c1fa55f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ecc5d134bd5008fea73701a4090764"><td class="memItemLeft" align="right" valign="top"><a id="a21ecc5d134bd5008fea73701a4090764"></a>
typedef <a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator_base</a>&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a21ecc5d134bd5008fea73701a4090764"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8dd241267b3b6fb8898ffadab831c2eb"><td class="memItemLeft" align="right" valign="top"><a id="a8dd241267b3b6fb8898ffadab831c2eb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a8dd241267b3b6fb8898ffadab831c2eb">vector</a> () noexcept</td></tr>
<tr class="memdesc:a8dd241267b3b6fb8898ffadab831c2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor, creates empty vector, maximum growth is 128k elements <br /></td></tr>
<tr class="separator:a8dd241267b3b6fb8898ffadab831c2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7d5673291570d5ac5a5ff4c00b8dc3"><td class="memItemLeft" align="right" valign="top"><a id="aff7d5673291570d5ac5a5ff4c00b8dc3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#aff7d5673291570d5ac5a5ff4c00b8dc3">vector</a> (size_t count, const T &amp;value=T(), size_t max_grow_=131072)</td></tr>
<tr class="memdesc:aff7d5673291570d5ac5a5ff4c00b8dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor to create vector of given size and potentially set maximum growth size <br /></td></tr>
<tr class="separator:aff7d5673291570d5ac5a5ff4c00b8dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9439a6ded24b97fbc3b57ba1518e2833"><td class="memTemplParams" colspan="2"><a id="a9439a6ded24b97fbc3b57ba1518e2833"></a>
template&lt;class It , typename std::enable_if&lt; at_least_input_iterator&lt; It &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a9439a6ded24b97fbc3b57ba1518e2833"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a9439a6ded24b97fbc3b57ba1518e2833">vector</a> (It first, It last, size_t max_grow_=131072)</td></tr>
<tr class="memdesc:a9439a6ded24b97fbc3b57ba1518e2833"><td class="mdescLeft">&#160;</td><td class="mdescRight">contructor from iterators and optionally setting maximum growth size <br /></td></tr>
<tr class="separator:a9439a6ded24b97fbc3b57ba1518e2833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa148596189a5a988724883b6c257fc7b"><td class="memItemLeft" align="right" valign="top"><a id="aa148596189a5a988724883b6c257fc7b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#aa148596189a5a988724883b6c257fc7b">vector</a> (const <a class="el" href="classstacked__vector_1_1vector.html">vector</a> &amp;v)</td></tr>
<tr class="memdesc:aa148596189a5a988724883b6c257fc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy and move constructors <br /></td></tr>
<tr class="separator:aa148596189a5a988724883b6c257fc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5fddb8d82583a2dfc530e72602a1fa"><td class="memItemLeft" align="right" valign="top"><a id="a7c5fddb8d82583a2dfc530e72602a1fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>vector</b> (<a class="el" href="classstacked__vector_1_1vector.html">vector</a> &amp;&amp;v)</td></tr>
<tr class="separator:a7c5fddb8d82583a2dfc530e72602a1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db230b5b9a6d2fa530e8c4620ce5f12"><td class="memItemLeft" align="right" valign="top"><a id="a1db230b5b9a6d2fa530e8c4620ce5f12"></a>
<a class="el" href="classstacked__vector_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classstacked__vector_1_1vector.html">vector</a> &amp;v)</td></tr>
<tr class="separator:a1db230b5b9a6d2fa530e8c4620ce5f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af126bc6043ad147738698e89cddec7ea"><td class="memItemLeft" align="right" valign="top"><a id="af126bc6043ad147738698e89cddec7ea"></a>
<a class="el" href="classstacked__vector_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classstacked__vector_1_1vector.html">vector</a> &amp;&amp;v)</td></tr>
<tr class="separator:af126bc6043ad147738698e89cddec7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68c3737ecd569fc4e0c7a83a8db3d3a"><td class="memItemLeft" align="right" valign="top"><a id="ad68c3737ecd569fc4e0c7a83a8db3d3a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classstacked__vector_1_1vector.html">vector</a> &amp;v)</td></tr>
<tr class="separator:ad68c3737ecd569fc4e0c7a83a8db3d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9575fa950c150367bc545d98754daea"><td class="memItemLeft" align="right" valign="top"><a id="ac9575fa950c150367bc545d98754daea"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#ac9575fa950c150367bc545d98754daea">size</a> () const</td></tr>
<tr class="memdesc:ac9575fa950c150367bc545d98754daea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current size, i.e. the number of elements stored in this vector. <br /></td></tr>
<tr class="separator:ac9575fa950c150367bc545d98754daea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f5be974ab9c71446e86e610acf283e"><td class="memItemLeft" align="right" valign="top"><a id="a41f5be974ab9c71446e86e610acf283e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a41f5be974ab9c71446e86e610acf283e">capacity</a> () const</td></tr>
<tr class="memdesc:a41f5be974ab9c71446e86e610acf283e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current capacity, i.e. the number of elements that can be stored without allocating more memory. <br /></td></tr>
<tr class="separator:a41f5be974ab9c71446e86e610acf283e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108d418538e968420cb0602c40ec4f14"><td class="memItemLeft" align="right" valign="top"><a id="a108d418538e968420cb0602c40ec4f14"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a108d418538e968420cb0602c40ec4f14">max_size</a> () const</td></tr>
<tr class="memdesc:a108d418538e968420cb0602c40ec4f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size to avoid overflow when calculating memory size. <br /></td></tr>
<tr class="separator:a108d418538e968420cb0602c40ec4f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ade37ec9016291c6d03a7632fffd92"><td class="memItemLeft" align="right" valign="top"><a id="a67ade37ec9016291c6d03a7632fffd92"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a67ade37ec9016291c6d03a7632fffd92">max_capacity</a> () const</td></tr>
<tr class="memdesc:a67ade37ec9016291c6d03a7632fffd92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum capacity to avoid overflow when calculating memory size. <br /></td></tr>
<tr class="separator:a67ade37ec9016291c6d03a7632fffd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4501f903fda79f3d2cd46b3caa4df262"><td class="memItemLeft" align="right" valign="top"><a id="a4501f903fda79f3d2cd46b3caa4df262"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a4501f903fda79f3d2cd46b3caa4df262">empty</a> () const</td></tr>
<tr class="memdesc:a4501f903fda79f3d2cd46b3caa4df262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the vector is empty. <br /></td></tr>
<tr class="separator:a4501f903fda79f3d2cd46b3caa4df262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2bb0ecb5b2d43cb1188ff243fccd19"><td class="memItemLeft" align="right" valign="top"><a id="a0c2bb0ecb5b2d43cb1188ff243fccd19"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a0c2bb0ecb5b2d43cb1188ff243fccd19">get_stack_array_size</a> () const</td></tr>
<tr class="memdesc:a0c2bb0ecb5b2d43cb1188ff243fccd19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum growth size. Separate arrays are allocated by this amount. <br /></td></tr>
<tr class="separator:a0c2bb0ecb5b2d43cb1188ff243fccd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebf8619e154db78d7f36805b7b4ba79"><td class="memItemLeft" align="right" valign="top"><a id="a6ebf8619e154db78d7f36805b7b4ba79"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a6ebf8619e154db78d7f36805b7b4ba79">operator[]</a> (size_t i)</td></tr>
<tr class="memdesc:a6ebf8619e154db78d7f36805b7b4ba79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the ith element. It is undefined behavior to if i &gt;= <a class="el" href="classstacked__vector_1_1vector.html#ac9575fa950c150367bc545d98754daea" title="Current size, i.e. the number of elements stored in this vector. ">size()</a> <br /></td></tr>
<tr class="separator:a6ebf8619e154db78d7f36805b7b4ba79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71935bd5967cdaffbf7959dc15b9f98"><td class="memItemLeft" align="right" valign="top"><a id="ae71935bd5967cdaffbf7959dc15b9f98"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#ae71935bd5967cdaffbf7959dc15b9f98">operator[]</a> (size_t i) const</td></tr>
<tr class="memdesc:ae71935bd5967cdaffbf7959dc15b9f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the ith element. It is undefined behavior to if i &gt;= <a class="el" href="classstacked__vector_1_1vector.html#ac9575fa950c150367bc545d98754daea" title="Current size, i.e. the number of elements stored in this vector. ">size()</a> <br /></td></tr>
<tr class="separator:ae71935bd5967cdaffbf7959dc15b9f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4591b571d3284bf55f4e23b9e7b64b"><td class="memItemLeft" align="right" valign="top"><a id="a1e4591b571d3284bf55f4e23b9e7b64b"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a1e4591b571d3284bf55f4e23b9e7b64b">at</a> (size_t i)</td></tr>
<tr class="memdesc:a1e4591b571d3284bf55f4e23b9e7b64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the ith element with bounds checking, throws an exception if i &gt;= <a class="el" href="classstacked__vector_1_1vector.html#ac9575fa950c150367bc545d98754daea" title="Current size, i.e. the number of elements stored in this vector. ">size()</a> <br /></td></tr>
<tr class="separator:a1e4591b571d3284bf55f4e23b9e7b64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4655689c3095694f755cfa9095b2c1a6"><td class="memItemLeft" align="right" valign="top"><a id="a4655689c3095694f755cfa9095b2c1a6"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a4655689c3095694f755cfa9095b2c1a6">at</a> (size_t i) const</td></tr>
<tr class="memdesc:a4655689c3095694f755cfa9095b2c1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the ith element with bounds checking, throws an exception if i &gt;= <a class="el" href="classstacked__vector_1_1vector.html#ac9575fa950c150367bc545d98754daea" title="Current size, i.e. the number of elements stored in this vector. ">size()</a> <br /></td></tr>
<tr class="separator:a4655689c3095694f755cfa9095b2c1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb8d7862d7fa2c1192a5a95fb8466b4"><td class="memItemLeft" align="right" valign="top"><a id="aabb8d7862d7fa2c1192a5a95fb8466b4"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#aabb8d7862d7fa2c1192a5a95fb8466b4">front</a> ()</td></tr>
<tr class="memdesc:aabb8d7862d7fa2c1192a5a95fb8466b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element. It is undefined behavior if this function is called on an empty vector. <br /></td></tr>
<tr class="separator:aabb8d7862d7fa2c1192a5a95fb8466b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222894a082af7b160124307a2fea2e16"><td class="memItemLeft" align="right" valign="top"><a id="a222894a082af7b160124307a2fea2e16"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a222894a082af7b160124307a2fea2e16">front</a> () const</td></tr>
<tr class="memdesc:a222894a082af7b160124307a2fea2e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element. It is undefined behavior if this function is called on an empty vector. <br /></td></tr>
<tr class="separator:a222894a082af7b160124307a2fea2e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516b0e9346a1c33a5f7e9fa1447c21e1"><td class="memItemLeft" align="right" valign="top"><a id="a516b0e9346a1c33a5f7e9fa1447c21e1"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a516b0e9346a1c33a5f7e9fa1447c21e1">back</a> ()</td></tr>
<tr class="memdesc:a516b0e9346a1c33a5f7e9fa1447c21e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element. It is undefined behavior if this function is called on an empty vector. <br /></td></tr>
<tr class="separator:a516b0e9346a1c33a5f7e9fa1447c21e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae150d50eb8a501dd0dddc763ea330b17"><td class="memItemLeft" align="right" valign="top"><a id="ae150d50eb8a501dd0dddc763ea330b17"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#ae150d50eb8a501dd0dddc763ea330b17">back</a> () const</td></tr>
<tr class="memdesc:ae150d50eb8a501dd0dddc763ea330b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element. It is undefined behavior if this function is called on an empty vector. <br /></td></tr>
<tr class="separator:ae150d50eb8a501dd0dddc763ea330b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6877e6826722f5d0b14f1510728801eb"><td class="memItemLeft" align="right" valign="top"><a id="a6877e6826722f5d0b14f1510728801eb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a6877e6826722f5d0b14f1510728801eb">reserve_nothrow</a> (size_t n)</td></tr>
<tr class="memdesc:a6877e6826722f5d0b14f1510728801eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve memory for at least n elements. Returns true if allocation was successfull, false otherwise. <br /></td></tr>
<tr class="separator:a6877e6826722f5d0b14f1510728801eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc10fd8b57f624a103deb1f8c1fec9d"><td class="memItemLeft" align="right" valign="top"><a id="a9cc10fd8b57f624a103deb1f8c1fec9d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a9cc10fd8b57f624a103deb1f8c1fec9d">reserve</a> (size_t n)</td></tr>
<tr class="memdesc:a9cc10fd8b57f624a103deb1f8c1fec9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve memory for at least n elements. Throws an exception if memory allocation is not successful. <br /></td></tr>
<tr class="separator:a9cc10fd8b57f624a103deb1f8c1fec9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1028ade2cdbb8647fb490fa79bc13a3"><td class="memItemLeft" align="right" valign="top"><a id="ab1028ade2cdbb8647fb490fa79bc13a3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#ab1028ade2cdbb8647fb490fa79bc13a3">shrink_to_fit</a> (size_t new_capacity=0)</td></tr>
<tr class="memdesc:ab1028ade2cdbb8647fb490fa79bc13a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free up unused memory, keeping at least the given new_capacity (if new_capacity &gt; <a class="el" href="classstacked__vector_1_1vector.html#ac9575fa950c150367bc545d98754daea">size()</a>). <br /></td></tr>
<tr class="separator:ab1028ade2cdbb8647fb490fa79bc13a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dba32bf55a20d5639f142daf1f24660"><td class="memItemLeft" align="right" valign="top"><a id="a6dba32bf55a20d5639f142daf1f24660"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a6dba32bf55a20d5639f142daf1f24660">push_back</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a6dba32bf55a20d5639f142daf1f24660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert element at the end of the vector. Can throw an exception if memory allocation fails. <br /></td></tr>
<tr class="separator:a6dba32bf55a20d5639f142daf1f24660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d1f8277171c273a6e14dd2c59cd62c"><td class="memItemLeft" align="right" valign="top"><a id="a19d1f8277171c273a6e14dd2c59cd62c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a19d1f8277171c273a6e14dd2c59cd62c">push_back</a> (T &amp;&amp;x)</td></tr>
<tr class="memdesc:a19d1f8277171c273a6e14dd2c59cd62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert element at the end of the vector. Can throw an exception if memory allocation fails. <br /></td></tr>
<tr class="separator:a19d1f8277171c273a6e14dd2c59cd62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0dd7a8b29fc8af795fb5ff18a91a88"><td class="memTemplParams" colspan="2"><a id="a3b0dd7a8b29fc8af795fb5ff18a91a88"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a3b0dd7a8b29fc8af795fb5ff18a91a88"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a3b0dd7a8b29fc8af795fb5ff18a91a88">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3b0dd7a8b29fc8af795fb5ff18a91a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an element at the end of the vector. Can throw an exception if memory allocation fails. <br /></td></tr>
<tr class="separator:a3b0dd7a8b29fc8af795fb5ff18a91a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0aae6e81c7ffe531315fa887a1a2a13"><td class="memItemLeft" align="right" valign="top"><a id="af0aae6e81c7ffe531315fa887a1a2a13"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#af0aae6e81c7ffe531315fa887a1a2a13">push_back_nothrow</a> (const T &amp;x)</td></tr>
<tr class="memdesc:af0aae6e81c7ffe531315fa887a1a2a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert element at the end of the vector. Does not throw exception, return value indicates if insert was successful. <br /></td></tr>
<tr class="separator:af0aae6e81c7ffe531315fa887a1a2a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace57a5443a22768da13daa182f0a6f65"><td class="memItemLeft" align="right" valign="top"><a id="ace57a5443a22768da13daa182f0a6f65"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#ace57a5443a22768da13daa182f0a6f65">push_back_nothrow</a> (T &amp;&amp;x)</td></tr>
<tr class="memdesc:ace57a5443a22768da13daa182f0a6f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert element at the end of the vector. Does not throw exception, return value indicates if insert was successful. <br /></td></tr>
<tr class="separator:ace57a5443a22768da13daa182f0a6f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad610fe832a0abe9dd973a6b1137c4ad2"><td class="memTemplParams" colspan="2"><a id="ad610fe832a0abe9dd973a6b1137c4ad2"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ad610fe832a0abe9dd973a6b1137c4ad2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#ad610fe832a0abe9dd973a6b1137c4ad2">emplace_back_nothrow</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad610fe832a0abe9dd973a6b1137c4ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an element at the end of the vector. Does not throw exception, return value indicates if insert was successful. <br /></td></tr>
<tr class="separator:ad610fe832a0abe9dd973a6b1137c4ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2241c6047363564fa6747eec922a3de5"><td class="memItemLeft" align="right" valign="top"><a id="a2241c6047363564fa6747eec922a3de5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a2241c6047363564fa6747eec922a3de5">clear</a> ()</td></tr>
<tr class="memdesc:a2241c6047363564fa6747eec922a3de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements; does not free up memory, use <a class="el" href="classstacked__vector_1_1vector.html#ab1028ade2cdbb8647fb490fa79bc13a3">shrink_to_fit()</a> for that. <br /></td></tr>
<tr class="separator:a2241c6047363564fa6747eec922a3de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1536005ff23ef495d5c723414cfe694"><td class="memItemLeft" align="right" valign="top"><a id="ac1536005ff23ef495d5c723414cfe694"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#ac1536005ff23ef495d5c723414cfe694">pop_back</a> ()</td></tr>
<tr class="memdesc:ac1536005ff23ef495d5c723414cfe694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element; does not free up memory, use <a class="el" href="classstacked__vector_1_1vector.html#ab1028ade2cdbb8647fb490fa79bc13a3">shrink_to_fit()</a> for that. <br /></td></tr>
<tr class="separator:ac1536005ff23ef495d5c723414cfe694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686553fbe4f53c5dadc11c59f7608766"><td class="memItemLeft" align="right" valign="top"><a id="a686553fbe4f53c5dadc11c59f7608766"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a686553fbe4f53c5dadc11c59f7608766">resize_nothrow</a> (size_t count)</td></tr>
<tr class="memdesc:a686553fbe4f53c5dadc11c59f7608766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize vector. If new size is larger than current size, new elements are default constructed. Does not throw exception on memory allocation error, return value indicates if resize was successful. <br /></td></tr>
<tr class="separator:a686553fbe4f53c5dadc11c59f7608766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050fc27a9532cd0829e6d599220e061a"><td class="memItemLeft" align="right" valign="top"><a id="a050fc27a9532cd0829e6d599220e061a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a050fc27a9532cd0829e6d599220e061a">resize_nothrow</a> (size_t count, const T &amp;x)</td></tr>
<tr class="memdesc:a050fc27a9532cd0829e6d599220e061a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize vector. If new size is larger than current size, new elements are inserted as copies of x. Does not throw exception on memory allocation error, return value indicates if resize was successful. <br /></td></tr>
<tr class="separator:a050fc27a9532cd0829e6d599220e061a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b27430ec837d28ff7451777a55553c9"><td class="memItemLeft" align="right" valign="top"><a id="a8b27430ec837d28ff7451777a55553c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a8b27430ec837d28ff7451777a55553c9">resize</a> (size_t count)</td></tr>
<tr class="memdesc:a8b27430ec837d28ff7451777a55553c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize vector. If new size is larger than current size, new elements are default constructed. Can throw an exception on memory allocation error. <br /></td></tr>
<tr class="separator:a8b27430ec837d28ff7451777a55553c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe55431611b470cf28dd03eeb65335da"><td class="memItemLeft" align="right" valign="top"><a id="abe55431611b470cf28dd03eeb65335da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#abe55431611b470cf28dd03eeb65335da">resize</a> (size_t count, const T &amp;x)</td></tr>
<tr class="memdesc:abe55431611b470cf28dd03eeb65335da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize vector. If new size is larger than current size, new elements are inserted as copies of x. Can throw exception on memory allocation error. <br /></td></tr>
<tr class="separator:abe55431611b470cf28dd03eeb65335da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6729dc795b5087f8e5e7c5fefafd51d6"><td class="memItemLeft" align="right" valign="top"><a id="a6729dc795b5087f8e5e7c5fefafd51d6"></a>
<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a6729dc795b5087f8e5e7c5fefafd51d6">begin</a> ()</td></tr>
<tr class="memdesc:a6729dc795b5087f8e5e7c5fefafd51d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to the beginning. <br /></td></tr>
<tr class="separator:a6729dc795b5087f8e5e7c5fefafd51d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6781b6b1f6389db8b3f0f1de73460d"><td class="memItemLeft" align="right" valign="top"><a id="a8d6781b6b1f6389db8b3f0f1de73460d"></a>
<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a8d6781b6b1f6389db8b3f0f1de73460d">begin</a> () const</td></tr>
<tr class="memdesc:a8d6781b6b1f6389db8b3f0f1de73460d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to the beginning. <br /></td></tr>
<tr class="separator:a8d6781b6b1f6389db8b3f0f1de73460d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5d3961e1e45e4d9a604144e0ab6bd3"><td class="memItemLeft" align="right" valign="top"><a id="a4a5d3961e1e45e4d9a604144e0ab6bd3"></a>
<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a4a5d3961e1e45e4d9a604144e0ab6bd3">cbegin</a> () const</td></tr>
<tr class="memdesc:a4a5d3961e1e45e4d9a604144e0ab6bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to the beginning. <br /></td></tr>
<tr class="separator:a4a5d3961e1e45e4d9a604144e0ab6bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e9a73ebeaa21c671230908d795647d"><td class="memItemLeft" align="right" valign="top"><a id="ab3e9a73ebeaa21c671230908d795647d"></a>
<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#ab3e9a73ebeaa21c671230908d795647d">end</a> ()</td></tr>
<tr class="memdesc:ab3e9a73ebeaa21c671230908d795647d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to the end. <br /></td></tr>
<tr class="separator:ab3e9a73ebeaa21c671230908d795647d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7408761dd06391a326fffb94d965f83b"><td class="memItemLeft" align="right" valign="top"><a id="a7408761dd06391a326fffb94d965f83b"></a>
<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a7408761dd06391a326fffb94d965f83b">end</a> () const</td></tr>
<tr class="memdesc:a7408761dd06391a326fffb94d965f83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to the end. <br /></td></tr>
<tr class="separator:a7408761dd06391a326fffb94d965f83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71af63cd9f92d1455bc8bc4d70be8e05"><td class="memItemLeft" align="right" valign="top"><a id="a71af63cd9f92d1455bc8bc4d70be8e05"></a>
<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a71af63cd9f92d1455bc8bc4d70be8e05">cend</a> () const</td></tr>
<tr class="memdesc:a71af63cd9f92d1455bc8bc4d70be8e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to the end. <br /></td></tr>
<tr class="separator:a71af63cd9f92d1455bc8bc4d70be8e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31ad8685d5e3e1018c6bc14f6006688"><td class="memItemLeft" align="right" valign="top"><a id="aa31ad8685d5e3e1018c6bc14f6006688"></a>
<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#aa31ad8685d5e3e1018c6bc14f6006688">erase</a> (<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">const_iterator</a> pos)</td></tr>
<tr class="memdesc:aa31ad8685d5e3e1018c6bc14f6006688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at the given position. <br /></td></tr>
<tr class="separator:aa31ad8685d5e3e1018c6bc14f6006688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31f0c326aa478cc0e3e1606e62a5e71"><td class="memItemLeft" align="right" valign="top"><a id="ae31f0c326aa478cc0e3e1606e62a5e71"></a>
<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#ae31f0c326aa478cc0e3e1606e62a5e71">erase</a> (<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">const_iterator</a> first, <a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">const_iterator</a> last)</td></tr>
<tr class="memdesc:ae31f0c326aa478cc0e3e1606e62a5e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements in the given range. <br /></td></tr>
<tr class="separator:ae31f0c326aa478cc0e3e1606e62a5e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb851412cde8b6d1cab01c945f86175"><td class="memItemLeft" align="right" valign="top"><a id="a4cb851412cde8b6d1cab01c945f86175"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a4cb851412cde8b6d1cab01c945f86175">insert_nothrow</a> (<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">const_iterator</a> pos, <a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator</a> &amp;res, const T &amp;x)</td></tr>
<tr class="memdesc:a4cb851412cde8b6d1cab01c945f86175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a copy of x at the given position. Does not throw an exception on memory allocation failure, the return value indicates if it was successful. The res iterator is updated to point to the inserted element if successful, otherwise it is not changed. <br /></td></tr>
<tr class="separator:a4cb851412cde8b6d1cab01c945f86175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cab0ace74b378e0da1cf1bce143867e"><td class="memItemLeft" align="right" valign="top"><a id="a3cab0ace74b378e0da1cf1bce143867e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a3cab0ace74b378e0da1cf1bce143867e">insert_nothrow</a> (<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">const_iterator</a> pos, <a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator</a> &amp;res, T &amp;&amp;x)</td></tr>
<tr class="memdesc:a3cab0ace74b378e0da1cf1bce143867e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts x at the given position. Does not throw an exception on memory allocation failure, the return value indicates if it was successful. The res iterator is updated to point to the inserted element if successful, otherwise it is not changed. <br /></td></tr>
<tr class="separator:a3cab0ace74b378e0da1cf1bce143867e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f2afae100bc4931e1102a4c81e7452"><td class="memItemLeft" align="right" valign="top"><a id="a14f2afae100bc4931e1102a4c81e7452"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a14f2afae100bc4931e1102a4c81e7452">insert_nothrow</a> (<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">const_iterator</a> pos, <a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator</a> &amp;res, size_t count, const T &amp;x)</td></tr>
<tr class="memdesc:a14f2afae100bc4931e1102a4c81e7452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts count copies of x at the given position. Does not throw an exception on memory allocation failure, the return value indicates if it was successful. The res iterator is updated to point to the inserted element if successful, otherwise it is not changed. <br /></td></tr>
<tr class="separator:a14f2afae100bc4931e1102a4c81e7452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565442638383acfbcd5d03b727668874"><td class="memTemplParams" colspan="2"><a id="a565442638383acfbcd5d03b727668874"></a>
template&lt;class InputIt , typename std::enable_if&lt; at_least_input_iterator&lt; InputIt &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a565442638383acfbcd5d03b727668874"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a565442638383acfbcd5d03b727668874">insert_nothrow</a> (<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">const_iterator</a> pos, <a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator</a> &amp;res, InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a565442638383acfbcd5d03b727668874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the elements in the range [first,last) at pos. Does not throw an exception on memory allocation failure, the return value indicates if it was successful. The res iterator is updated to point to the inserted element if successful, otherwise it is not changed. <br /></td></tr>
<tr class="separator:a565442638383acfbcd5d03b727668874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e583b37da3f00c576cf72d3664d6d7a"><td class="memItemLeft" align="right" valign="top"><a id="a7e583b37da3f00c576cf72d3664d6d7a"></a>
<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a7e583b37da3f00c576cf72d3664d6d7a">insert</a> (<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">const_iterator</a> pos, const T &amp;x)</td></tr>
<tr class="memdesc:a7e583b37da3f00c576cf72d3664d6d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a copy of x at pos. Can throw an exception if out of memory. <br /></td></tr>
<tr class="separator:a7e583b37da3f00c576cf72d3664d6d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7802affa080f783b9a08c8b304b02abb"><td class="memItemLeft" align="right" valign="top"><a id="a7802affa080f783b9a08c8b304b02abb"></a>
<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a7802affa080f783b9a08c8b304b02abb">insert</a> (<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">const_iterator</a> pos, T &amp;&amp;x)</td></tr>
<tr class="memdesc:a7802affa080f783b9a08c8b304b02abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts x at pos. Can throw an exception if out of memory. <br /></td></tr>
<tr class="separator:a7802affa080f783b9a08c8b304b02abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3731ca7b02753bce29407cceef0509"><td class="memItemLeft" align="right" valign="top"><a id="a4b3731ca7b02753bce29407cceef0509"></a>
<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a4b3731ca7b02753bce29407cceef0509">insert</a> (<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">const_iterator</a> pos, size_t count, const T &amp;x)</td></tr>
<tr class="memdesc:a4b3731ca7b02753bce29407cceef0509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts count copies of x at pos. Can throw an exception if out of memory. <br /></td></tr>
<tr class="separator:a4b3731ca7b02753bce29407cceef0509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d6f22ec404c4abd394cc2b697d5749"><td class="memTemplParams" colspan="2"><a id="a10d6f22ec404c4abd394cc2b697d5749"></a>
template&lt;class InputIt , typename std::enable_if&lt; at_least_input_iterator&lt; InputIt &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a10d6f22ec404c4abd394cc2b697d5749"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a10d6f22ec404c4abd394cc2b697d5749">insert</a> (<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">const_iterator</a> pos, InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a10d6f22ec404c4abd394cc2b697d5749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the elements in the range [first,last) at pos. Can throw an exception if out of memory. <br /></td></tr>
<tr class="separator:a10d6f22ec404c4abd394cc2b697d5749"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6f8e3b19c0b80d6bf0843f941fd6f694"><td class="memTemplParams" colspan="2"><a id="a6f8e3b19c0b80d6bf0843f941fd6f694"></a>
template&lt;class U  = T&gt; </td></tr>
<tr class="memitem:a6f8e3b19c0b80d6bf0843f941fd6f694"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a6f8e3b19c0b80d6bf0843f941fd6f694">copy_or_move</a> (U *target, size_t new_size, typename std::enable_if&lt; std::is_nothrow_move_constructible&lt; U &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a6f8e3b19c0b80d6bf0843f941fd6f694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to copy or move values to new array, selecting copy or move based on SFINAE. <br /></td></tr>
<tr class="separator:a6f8e3b19c0b80d6bf0843f941fd6f694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445cd8143ee9248ed8b72dde97ef75e1"><td class="memTemplParams" colspan="2"><a id="a445cd8143ee9248ed8b72dde97ef75e1"></a>
template&lt;class U  = T&gt; </td></tr>
<tr class="memitem:a445cd8143ee9248ed8b72dde97ef75e1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_or_move</b> (U *target, size_t new_size, typename std::enable_if&lt; ! std::is_nothrow_move_constructible&lt; U &gt;::value &gt;::type *=0)</td></tr>
<tr class="separator:a445cd8143ee9248ed8b72dde97ef75e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa83eabe63a09f463232c129e88a8606"><td class="memItemLeft" align="right" valign="top"><a id="aaa83eabe63a09f463232c129e88a8606"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#aaa83eabe63a09f463232c129e88a8606">change_size</a> (size_t new_size)</td></tr>
<tr class="memdesc:aaa83eabe63a09f463232c129e88a8606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate memory in the first stack element to the given new size, moving / copying elements to the new location. new_size must be &gt; 0, but can be less than p_size. <br /></td></tr>
<tr class="separator:aaa83eabe63a09f463232c129e88a8606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4be5072baea2163de5e94b18761f481"><td class="memItemLeft" align="right" valign="top"><a id="ad4be5072baea2163de5e94b18761f481"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#ad4be5072baea2163de5e94b18761f481">grow_vector</a> (size_t minimum_size=0)</td></tr>
<tr class="memdesc:ad4be5072baea2163de5e94b18761f481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to grow vector either to the given minimum size or using the default strategy, i.e. doubling size until the first element in the stack is full and after allocating max_grow elements at a time. <br /></td></tr>
<tr class="separator:ad4be5072baea2163de5e94b18761f481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7aff360c12bb0b4d89efe45ab566879"><td class="memItemLeft" align="right" valign="top"><a id="aa7aff360c12bb0b4d89efe45ab566879"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#aa7aff360c12bb0b4d89efe45ab566879">grow_one</a> ()</td></tr>
<tr class="memdesc:aa7aff360c12bb0b4d89efe45ab566879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add one element to the stack. <br /></td></tr>
<tr class="separator:aa7aff360c12bb0b4d89efe45ab566879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2345fd0f3640d288bf99ec5c47cf0a4e"><td class="memItemLeft" align="right" valign="top"><a id="a2345fd0f3640d288bf99ec5c47cf0a4e"></a>
std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a2345fd0f3640d288bf99ec5c47cf0a4e">get_indices</a> (size_t i) const</td></tr>
<tr class="memdesc:a2345fd0f3640d288bf99ec5c47cf0a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to get internal indices (which stack + position in stack) based on item index. <br /></td></tr>
<tr class="separator:a2345fd0f3640d288bf99ec5c47cf0a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e11389cac93186ec70f00b67880f1a"><td class="memItemLeft" align="right" valign="top"><a id="af8e11389cac93186ec70f00b67880f1a"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#af8e11389cac93186ec70f00b67880f1a">get_addr</a> (size_t i)</td></tr>
<tr class="memdesc:af8e11389cac93186ec70f00b67880f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to get memory address of element at index. Does not check if index is in range, it is undefined behavior to call this function with i &gt;= <a class="el" href="classstacked__vector_1_1vector.html#ac9575fa950c150367bc545d98754daea">size()</a>. <br /></td></tr>
<tr class="separator:af8e11389cac93186ec70f00b67880f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3dc287aba77e1c9ecb69062e2a60714"><td class="memItemLeft" align="right" valign="top"><a id="ae3dc287aba77e1c9ecb69062e2a60714"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#ae3dc287aba77e1c9ecb69062e2a60714">get_addr</a> (size_t i) const</td></tr>
<tr class="memdesc:ae3dc287aba77e1c9ecb69062e2a60714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to get memory address of element at index. Does not check if index is in range, it is undefined behavior to call this function with i &gt;= <a class="el" href="classstacked__vector_1_1vector.html#ac9575fa950c150367bc545d98754daea">size()</a>. <br /></td></tr>
<tr class="separator:ae3dc287aba77e1c9ecb69062e2a60714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5cd04ccdecc5e8dedbe863384b7130"><td class="memItemLeft" align="right" valign="top"><a id="abb5cd04ccdecc5e8dedbe863384b7130"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#abb5cd04ccdecc5e8dedbe863384b7130">get_ref</a> (size_t i)</td></tr>
<tr class="memdesc:abb5cd04ccdecc5e8dedbe863384b7130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to get reference of element at index. Does not check if index is in range, it is undefined behavior to call this function with i &gt;= <a class="el" href="classstacked__vector_1_1vector.html#ac9575fa950c150367bc545d98754daea">size()</a>. <br /></td></tr>
<tr class="separator:abb5cd04ccdecc5e8dedbe863384b7130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac241bbd1bad262bda5baaa4660881da1"><td class="memItemLeft" align="right" valign="top"><a id="ac241bbd1bad262bda5baaa4660881da1"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#ac241bbd1bad262bda5baaa4660881da1">get_ref</a> (size_t i) const</td></tr>
<tr class="memdesc:ac241bbd1bad262bda5baaa4660881da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to get reference of element at index. Does not check if index is in range, it is undefined behavior to call this function with i &gt;= <a class="el" href="classstacked__vector_1_1vector.html#ac9575fa950c150367bc545d98754daea">size()</a>. <br /></td></tr>
<tr class="separator:ac241bbd1bad262bda5baaa4660881da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6907b08aa3c007ebe321c4e89a70a722"><td class="memItemLeft" align="right" valign="top"><a id="a6907b08aa3c007ebe321c4e89a70a722"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a6907b08aa3c007ebe321c4e89a70a722">insert_helper</a> (size_t pos, size_t new_pos)</td></tr>
<tr class="memdesc:a6907b08aa3c007ebe321c4e89a70a722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for the insert functions &ndash; moves elements starting from pos to new_pos, allocating memory if necessary. The caller must ensure that new_pos &gt;= pos and p_size &gt; pos. <br /></td></tr>
<tr class="separator:a6907b08aa3c007ebe321c4e89a70a722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c99f1ceab05a4a333b0084cd0b36f2"><td class="memItemLeft" align="right" valign="top"><a id="a22c99f1ceab05a4a333b0084cd0b36f2"></a>
<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator_base</a>&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a22c99f1ceab05a4a333b0084cd0b36f2">make_iterator</a> (size_t pos)</td></tr>
<tr class="memdesc:a22c99f1ceab05a4a333b0084cd0b36f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to create an iterator based on a position. <br /></td></tr>
<tr class="separator:a22c99f1ceab05a4a333b0084cd0b36f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa824378014e04cc25939dc73e1c74c"><td class="memItemLeft" align="right" valign="top"><a id="aaaa824378014e04cc25939dc73e1c74c"></a>
<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator_base</a>&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#aaaa824378014e04cc25939dc73e1c74c">make_iterator</a> (<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator_base</a>&lt; true &gt; pos)</td></tr>
<tr class="memdesc:aaaa824378014e04cc25939dc73e1c74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to make a non-const copy of a const iterator &ndash; only possible if this class is not const. <br /></td></tr>
<tr class="separator:aaaa824378014e04cc25939dc73e1c74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c41f281cf448591027b0822ff872a7"><td class="memItemLeft" align="right" valign="top"><a id="a58c41f281cf448591027b0822ff872a7"></a>
<a class="el" href="classstacked__vector_1_1vector_1_1iterator__base.html">iterator_base</a>&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a58c41f281cf448591027b0822ff872a7">make_iterator</a> (size_t pos) const</td></tr>
<tr class="memdesc:a58c41f281cf448591027b0822ff872a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to create an iterator based on a position. <br /></td></tr>
<tr class="separator:a58c41f281cf448591027b0822ff872a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a77ef86522e0b4d4b169ebd136432e14c"><td class="memItemLeft" align="right" valign="top"><a id="a77ef86522e0b4d4b169ebd136432e14c"></a>
vector_type&lt; T * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>stack</b></td></tr>
<tr class="separator:a77ef86522e0b4d4b169ebd136432e14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efc976959f33a242fbeef6c8b792678"><td class="memItemLeft" align="right" valign="top"><a id="a2efc976959f33a242fbeef6c8b792678"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a2efc976959f33a242fbeef6c8b792678">p_size</a></td></tr>
<tr class="memdesc:a2efc976959f33a242fbeef6c8b792678"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of elements in vector <br /></td></tr>
<tr class="separator:a2efc976959f33a242fbeef6c8b792678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8451e97870fcf3c6130f0891add5096"><td class="memItemLeft" align="right" valign="top"><a id="aa8451e97870fcf3c6130f0891add5096"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#aa8451e97870fcf3c6130f0891add5096">p_capacity</a></td></tr>
<tr class="memdesc:aa8451e97870fcf3c6130f0891add5096"><td class="mdescLeft">&#160;</td><td class="mdescRight">current capacity of vector <br /></td></tr>
<tr class="separator:aa8451e97870fcf3c6130f0891add5096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e19b80b9d73c902b2d68df4bbd5259"><td class="memItemLeft" align="right" valign="top"><a id="a74e19b80b9d73c902b2d68df4bbd5259"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a74e19b80b9d73c902b2d68df4bbd5259">p_stack_size</a></td></tr>
<tr class="memdesc:a74e19b80b9d73c902b2d68df4bbd5259"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of one array in the stack <br /></td></tr>
<tr class="separator:a74e19b80b9d73c902b2d68df4bbd5259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef039bf2764b2a09c3f442fd79b0ecc"><td class="memItemLeft" align="right" valign="top"><a id="a8ef039bf2764b2a09c3f442fd79b0ecc"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#a8ef039bf2764b2a09c3f442fd79b0ecc">max_grow</a></td></tr>
<tr class="memdesc:a8ef039bf2764b2a09c3f442fd79b0ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">grow memory by maximum this many elements at a time, i.e. maximum value for p_stack_size. Does not change, but not const to allow for swapping / copying / moving vectors with different value. <br /></td></tr>
<tr class="separator:a8ef039bf2764b2a09c3f442fd79b0ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:af15765ebc07c2c28c06be93adbd6741d"><td class="memItemLeft" align="right" valign="top"><a id="af15765ebc07c2c28c06be93adbd6741d"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstacked__vector_1_1vector.html#af15765ebc07c2c28c06be93adbd6741d">p_max_capacity</a> = std::numeric_limits&lt;size_t&gt;::max() / sizeof(T)</td></tr>
<tr class="memdesc:af15765ebc07c2c28c06be93adbd6741d"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum safe capacity to avoid overflow <br /></td></tr>
<tr class="separator:af15765ebc07c2c28c06be93adbd6741d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, template&lt; class &gt; class vector_type = std_vector_wrapper&gt;<br />
class stacked_vector::vector&lt; T, vector_type &gt;</h3>

<p>C++ vector-like container that internally maintains a "stack" of vectors instead of having one large resizeable storage. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type stored in this vector. </td></tr>
    <tr><td class="paramname">vector_type</td><td>Container type to use for storing pointers to the individual arrays</td></tr>
  </table>
  </dd>
</dl>
<p>Main motivation for this class are the following perceived issues with std::vector:</p>
<ol type="1">
<li>An std::vector always grows by a fixed factor (typically 2, i.e. doubling capacity on most implementations). This is required to avoid O(n^2) copies of elements if growing a vector requires copying all elements (see below). Thus, if a vector is full with N elements, memory requirement jumps up to 2*N, which might end up wasting memory space.</li>
<li>Since the stored type in std::vector is not necessarily trivially copyable (cannot be moved with memcopy() / memmove()), any change in capacity needs to be performed in three steps: 1. allocate new memory; 2. copy elements; 3. free previous memory. This way, it is not possible to use any optimizations offered by realloc() (e.g. using mremap() on Linux for large allocations). Growing a vector of size N then actually requires allocating memory in total for 3*N elements, and using 2*N elements of it for the duration of the grow.</li>
</ol>
<p>This class addresses these issues by storing multiple arrays of fixed size instead of one large allocation. These array are stored in a "stack", thus they can be dynamically added or removed. Growing the vector then results in fixed memory allocations and there is no need to copy / move elements.</p>
<p>The downside is that indexing is more complicated, i.e. it includes an extra division and an extra memory lookup operation, thus it can be significantly slower than using a regular vector.</p>
<p>This can be mitigated by optimizing divide operations with the use of the <a href="https://github.com/ridiculousfish/libdivide">libdivide library</a>. To do this, download libdivide.h and place it in the same directory and define USE_LIBDIVIDE (e.g. by the by adding -DUSE_LIBDIVIDE command line argument if compiling with g++). </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="vector__stacked_8h_source.html">vector_stacked.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
